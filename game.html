<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Match In Progress - HandiCricket</title>
  <style>
    :root {
      --primary-color: #1e88e5;
      --secondary-color: #1565c0;
      --accent-color: #ffeb3b;
      --success-color: #4CAF50;
      --warning-color: #FF9800;
      --danger-color: #F44336;
      --text-primary: #212121;
      --text-secondary: #757575;
      --bg-color: #f5f5f5;
      --card-bg: #ffffff;
      --border-color: #e0e0e0;
      --shadow: 0 2px 4px rgba(0,0,0,0.1);
      --shadow-lg: 0 4px 12px rgba(0,0,0,0.15);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background: var(--bg-color);
      color: var(--text-primary);
      line-height: 1.6;
    }

    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1rem;
    }

    .header {
      background: var(--primary-color);
      color: white;
      padding: 1rem 0;
      box-shadow: var(--shadow);
    }

    .logo {
      font-size: 1.5rem;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .match-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }

    .room-code {
      background: rgba(255,255,255,0.2);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }

    .format-display {
      font-weight: 500;
    }

    .spectator-count {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-primary {
      background: var(--primary-color);
      color: white;
    }

    .btn-primary:hover {
      background: var(--secondary-color);
    }

    .btn-secondary {
      background: var(--border-color);
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background: #d0d0d0;
    }

    .btn-warning {
      background: var(--warning-color);
      color: white;
    }

    .btn-warning:hover {
      background: #e68a00;
    }

    .btn-danger {
      background: var(--danger-color);
      color: white;
    }

    .btn-danger:hover {
      background: #d32f2f;
    }

    /* Game Container Styles */
    .game-container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 1rem;
    }

    .match-status {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--card-bg);
      padding: 1rem;
      border-radius: 12px;
      margin-bottom: 1rem;
      box-shadow: var(--shadow);
    }

    .innings-display {
      font-size: 1.2rem;
      font-weight: bold;
      color: var(--primary-color);
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.9rem;
    }

    .connection-status.online {
      background: rgba(76, 175, 80, 0.2);
      color: var(--success-color);
    }

    .connection-status.offline {
      background: rgba(244, 67, 54, 0.2);
      color: var(--danger-color);
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
    }

    /* Scoreboard Styles */
    .scoreboard {
      background: var(--card-bg);
      padding: 2rem;
      border-radius: 16px;
      margin-bottom: 1rem;
      box-shadow: var(--shadow-lg);
    }

    .score-main {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .batting-team h3 {
      color: var(--primary-color);
      margin-bottom: 0.5rem;
      font-size: 1.5rem;
    }

    .score-display {
      font-size: 3rem;
      font-weight: bold;
      color: var(--text-primary);
    }

    .runs {
      color: var(--success-color);
    }

    .wickets {
      color: var(--danger-color);
    }

    .separator {
      color: var(--text-secondary);
      margin: 0 0.5rem;
    }

    .overs-display {
      font-size: 1.5rem;
      color: var(--text-secondary);
      margin-left: 1rem;
    }

    .target-display {
      text-align: right;
    }

    .target-text {
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--warning-color);
      margin-bottom: 0.5rem;
    }

    .required-info {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .req-rate {
      font-weight: 500;
    }

    .score-details {
      display: flex;
      justify-content: space-between;
      padding-top: 1rem;
      border-top: 1px solid var(--border-color);
    }

    .score-details .label {
      color: var(--text-secondary);
      margin-right: 0.5rem;
    }

    .score-details .value {
      color: var(--primary-color);
      font-weight: 500;
    }

    /* Current Players Styles */
    .current-players {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .player-card {
      background: var(--card-bg);
      padding: 1.5rem;
      border-radius: 12px;
      text-align: center;
      box-shadow: var(--shadow);
    }

    .player-card h4 {
      color: var(--primary-color);
      margin-bottom: 0.5rem;
    }

    .player-name {
      font-size: 1.2rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }

    .player-stats {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .player-lives {
      margin-top: 0.5rem;
      font-size: 1.2rem;
    }

    /* Special Indicators */
    .special-indicators {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .indicator {
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-weight: bold;
      font-size: 0.9rem;
    }

    .indicator.powerplay {
      background: var(--accent-color);
      color: black;
    }

    .indicator.free-hit {
      background: var(--success-color);
      color: white;
    }

    .indicator.dead-over {
      background: var(--danger-color);
      color: white;
    }

    /* Game Status */
    .game-status {
      background: var(--card-bg);
      padding: 1.5rem;
      border-radius: 12px;
      text-align: center;
      margin-bottom: 1rem;
      box-shadow: var(--shadow);
    }

    .status-message {
      font-size: 1.2rem;
      font-weight: bold;
      color: var(--primary-color);
      margin-bottom: 0.5rem;
    }

    .role-text {
      color: var(--text-secondary);
    }

    /* Card Selection */
    .card-selection {
      background: var(--card-bg);
      padding: 2rem;
      border-radius: 16px;
      text-align: center;
      margin-bottom: 1rem;
      box-shadow: var(--shadow-lg);
    }

    .card-selection h3 {
      color: var(--primary-color);
      margin-bottom: 1.5rem;
    }

    .card-row {
      display: flex;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .card {
      width: 70px;
      height: 70px;
      font-size: 24px;
      border-radius: 12px;
      border: 3px solid var(--primary-color);
      background: white;
      color: var(--primary-color);
      font-weight: bold;
      box-shadow: var(--shadow);
      transition: all 0.2s;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .card:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }

    .card:active {
      transform: translateY(1px);
    }

    .card:disabled {
      background: #f5f5f5;
      color: #999;
      border-color: #ddd;
      cursor: not-allowed;
    }

    .card-selected {
      background: var(--primary-color);
      color: white;
      transform: scale(1.05);
    }

    .selected-card {
      margin-top: 1rem;
      padding: 1rem;
      background: rgba(30, 136, 229, 0.2);
      border-radius: 8px;
      color: var(--primary-color);
      font-weight: bold;
    }

    /* Ball Results */
    .ball-result {
      background: var(--card-bg);
      padding: 2rem;
      border-radius: 16px;
      margin-bottom: 1rem;
      box-shadow: var(--shadow-lg);
    }

    .result-content {
      text-align: center;
    }

    .choices {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2rem;
      margin-bottom: 1.5rem;
    }

    .choice {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .choice-value {
      font-size: 2rem;
      font-weight: bold;
      color: var(--primary-color);
      padding: 1rem;
      background: var(--border-color);
      border-radius: 50%;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .vs {
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--accent-color);
    }

    .ball-outcome {
      font-size: 1.3rem;
      font-weight: bold;
      padding: 1rem;
      border-radius: 8px;
    }

    /* Playing XI */
    .playing-xi {
      background: var(--card-bg);
      padding: 1.5rem;
      border-radius: 12px;
      margin-bottom: 1rem;
      box-shadow: var(--shadow);
    }

    .teams-display {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
    }

    .team-section h4 {
      color: var(--primary-color);
      margin-bottom: 1rem;
      text-align: center;
    }

    .player-list {
      list-style: none;
      padding: 0;
    }

    .player-item {
      padding: 0.5rem;
      margin-bottom: 0.25rem;
      border-radius: 6px;
      background: var(--border-color);
    }

    .player-item.current-batter {
      background: rgba(76, 175, 80, 0.2);
      color: var(--success-color);
    }

    .player-item.current-bowler {
      background: rgba(30, 136, 229, 0.2);
      color: var(--primary-color);
    }

    .player-item.out {
      background: rgba(244, 67, 54, 0.2);
      color: var(--danger-color);
      opacity: 0.7;
    }

    /* Game Controls */
    .game-controls {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-top: 2rem;
    }

    .test-controls {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    /* Player Selection Modal */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-content {
      background: var(--card-bg);
      padding: 2rem;
      border-radius: 12px;
      width: 90%;
      max-width: 500px;
      box-shadow: var(--shadow-lg);
    }

    .player-list {
      max-height: 300px;
      overflow-y: auto;
      margin: 1rem 0;
    }

    .player-option {
      padding: 1rem;
      margin: 0.5rem 0;
      background: var(--border-color);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .player-option:hover {
      background: var(--primary-color);
      color: white;
    }

    .player-option.selected {
      background: var(--primary-color);
      color: white;
    }

    /* Animations */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    @keyframes glow {
      0% { box-shadow: 0 0 5px rgba(76, 175, 80, 0.7); }
      50% { box-shadow: 0 0 20px rgba(76, 175, 80, 0.7); }
      100% { box-shadow: 0 0 5px rgba(76, 175, 80, 0.7); }
    }

    .powerplay-pulse {
      animation: pulse 1.5s infinite;
    }

    .glow {
      animation: glow 2s infinite;
    }

    /* Responsive Styles */
    @media (max-width: 768px) {
      .score-main {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
      }

      .score-display {
        font-size: 2.5rem;
      }

      .current-players {
        grid-template-columns: 1fr;
      }

      .teams-display {
        grid-template-columns: 1fr;
      }

      .choices {
        flex-direction: column;
        gap: 1rem;
      }

      .game-controls {
        flex-direction: column;
        align-items: center;
      }

      .test-controls {
        flex-direction: column;
        align-items: center;
      }
    }

    /* Loading Overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      color: white;
    }

    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-bottom: 1rem;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Error Modal */
    .error-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    .error-content {
      background: white;
      padding: 2rem;
      border-radius: 8px;
      max-width: 500px;
      width: 90%;
      text-align: center;
    }

    .error-content h3 {
      color: var(--danger-color);
      margin-bottom: 1rem;
    }

    /* Notifications */
    .notification {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 1rem 2rem;
      border-radius: 8px;
      color: white;
      font-weight: bold;
      box-shadow: var(--shadow-lg);
      z-index: 1000;
      animation: slideIn 0.3s, fadeOut 0.5s 2.5s forwards;
    }

    @keyframes slideIn {
      from { top: -100px; opacity: 0; }
      to { top: 20px; opacity: 1; }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    .notification.success {
      background: var(--success-color);
    }

    .notification.warning {
      background: var(--warning-color);
    }

    .notification.error {
      background: var(--danger-color);
    }

    .notification.info {
      background: var(--primary-color);
    }

    /* Confetti */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background-color: #f00;
      opacity: 0;
      animation: confetti-fall 5s ease-in-out forwards;
      z-index: 999;
    }

    @keyframes confetti-fall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div id="loading-overlay" class="loading-overlay">
    <div class="loading-spinner"></div>
    <p>Loading match...</p>
  </div>

  <div id="error-modal" class="error-modal" style="display: none;">
    <div class="error-content">
      <h3>Error</h3>
      <p id="error-message"></p>
      <button id="retry-btn" class="btn btn-primary">Try Again</button>
    </div>
  </div>

  <header class="header">
    <div class="container">
      <h1 class="logo">
        <span class="cricket-icon">🏏</span>
        HandiCricket
      </h1>
      <div class="match-header">
        <div id="roomCode" class="room-code"></div>
        <div id="formatDisplay" class="format-display"></div>
        <div id="spectatorCount" class="spectator-count">👥 0</div>
      </div>
    </div>
  </header>

  <main class="main game-container">
    <!-- Match Status -->
    <div class="match-status">
      <div id="currentInnings" class="innings-display">1st Innings</div>
      <div id="connectionStatus" class="connection-status online">
        <span class="status-indicator"></span>
        <span class="status-text">Connected</span>
      </div>
    </div>

    <!-- Scoreboard -->
    <div class="scoreboard">
      <div class="score-main">
        <div class="batting-team">
          <h3 id="battingTeamName">Team A</h3>
          <div class="score-display">
            <span id="runs" class="runs">0</span>
            <span class="separator">/</span>
            <span id="wickets" class="wickets">0</span>
            <span class="overs-display">(<span id="overs">0.0</span>)</span>
          </div>
        </div>
        <div class="target-display" id="targetDisplay" style="display: none;">
          <div class="target-text">Target: <span id="target">0</span></div>
          <div class="required-info">
            <span>Need <span id="runsRequired">0</span> from <span id="ballsRemaining">0</span> balls</span>
            <span class="req-rate">RR: <span id="requiredRate">0.00</span></span>
          </div>
        </div>
      </div>
      
      <div class="score-details">
        <div class="run-rate">
          <span class="label">Run Rate:</span>
          <span id="currentRunRate" class="value">0.00</span>
        </div>
        <div class="last-over">
          <span class="label">Last Over:</span>
          <span id="lastOverRuns" class="value">0 runs</span>
        </div>
      </div>
    </div>

    <!-- Current Players -->
    <div class="current-players">
      <div class="player-card">
        <h4>Batter</h4>
        <div id="currentBatter" class="player-name">-</div>
        <div id="batterStats" class="player-stats">0(0)</div>
        <div id="batterLives" class="player-lives"></div>
      </div>
      <div class="player-card">
        <h4>Bowler</h4>
        <div id="currentBowler" class="player-name">-</div>
        <div id="bowlerStats" class="player-stats">0-0-0-0</div>
        <div id="bowlerOvers" class="player-overs"></div>
      </div>
    </div>

    <!-- Special Indicators -->
    <div class="special-indicators">
      <div id="powerplayIndicator" class="indicator powerplay" style="display: none;">
        ⚡ POWERPLAY
      </div>
      <div id="freeHitIndicator" class="indicator free-hit" style="display: none;">
        🎯 FREE HIT
      </div>
      <div id="deadOverIndicator" class="indicator dead-over" style="display: none;">
        💀 DEAD OVER
      </div>
    </div>

    <!-- Game Status -->
    <div id="gameStatus" class="game-status">
      <div id="statusMessage" class="status-message">Ready to play</div>
      <div id="roleText" class="role-text"></div>
    </div>

    <!-- Card Selection -->
    <div class="card-selection">
      <h3>Select Your Number</h3>
      <div class="card-row">
        <button class="card" data-value="0">0</button>
        <button class="card" data-value="1">1</button>
        <button class="card" data-value="2">2</button>
        <button class="card" data-value="3">3</button>
        <button class="card" data-value="4">4</button>
        <button class="card" data-value="5">5</button>
        <button class="card" data-value="6">6</button>
      </div>
      <div id="selectedCard" class="selected-card" style="display: none;">
        You selected: <span class="selected-value"></span>
      </div>
    </div>

    <!-- Ball Results -->
    <div id="ballResult" class="ball-result" style="display: none;">
      <div class="result-content">
        <div class="choices">
          <div class="choice">
            <span class="player">You:</span>
            <span id="playerChoice" class="choice-value">0</span>
          </div>
          <div class="vs">VS</div>
          <div class="choice">
            <span class="player">Opponent:</span>
            <span id="opponentChoice" class="choice-value">0</span>
          </div>
        </div>
        <div id="ballOutcome" class="ball-outcome">
          <!-- Dynamic result content -->
        </div>
      </div>
    </div>

    <!-- Player Selection Modal -->
    <div id="playerSelectionModal" class="modal" style="display: none;">
      <div class="modal-content">
        <h3 id="selectionTitle">Select Next Batter</h3>
        <div id="playerList" class="player-list">
          <!-- Dynamic player list -->
        </div>
        <button id="confirmPlayerSelection" class="btn btn-primary">Confirm Selection</button>
      </div>
    </div>

    <!-- Test Match Controls -->
    <div id="testControls" class="test-controls" style="display: none;">
      <button id="declareInnings" class="btn btn-warning">Declare Innings</button>
      <button id="enforceFollowOn" class="btn btn-secondary" style="display: none;">Enforce Follow-On</button>
    </div>

    <!-- Playing XI -->
    <div class="playing-xi">
      <div class="teams-display">
        <div class="team-section">
          <h4 id="team1Name">Team 1</h4>
          <ul id="team1Players" class="player-list"></ul>
        </div>
        <div class="team-section">
          <h4 id="team2Name">Team 2</h4>
          <ul id="team2Players" class="player-list"></ul>
        </div>
      </div>
    </div>

    <!-- Game Controls -->
    <div class="game-controls">
      <button id="saveGame" class="btn btn-warning">💾 Save Game</button>
      <button id="exitGame" class="btn btn-danger">🚪 Exit Game</button>
      <button id="resetPlaysBtn" class="btn btn-secondary">🔄 Reset Plays</button>
    </div>
  </main>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
    import { getDatabase, ref, onValue, set, get, update, push } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAGU0Tsj9pwZcgwQjZzTFvGOE032l2b7HI",
      authDomain: "handicricket-d1ab7.firebaseapp.com",
      projectId: "handicricket-d1ab7",
      storageBucket: "handicricket-d1ab7.appspot.com",
      messagingSenderId: "356065986337",
      appId: "1:356065986337:web:399102c5dabfca2b6fe060"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const params = new URLSearchParams(window.location.search);
    const room = params.get('room');
    const player = params.get('player');
    const opponent = player === "player1" ? "player2" : "player1";
    const isAIMode = room.includes('AI');

    // AI Player Logic
    class AIOpponent {
      constructor(difficulty = 'medium') {
        this.difficulty = difficulty;
      }

      makePlay(currentSituation) {
        // Current situation includes:
        // - runs, wickets, overs, target (if chasing)
        // - isPowerplay, isDeadOver
        // - currentBatterStats, currentBowlerStats
        
        // Simple AI logic - can be enhanced based on difficulty
        if (currentSituation.isBatting) {
          return this.makeBattingPlay(currentSituation);
        } else {
          return this.makeBowlingPlay(currentSituation);
        }
      }

      makeBattingPlay(situation) {
        // More aggressive in powerplay, more conservative when defending
        const aggression = situation.isPowerplay ? 0.7 : 
                          (situation.target ? (situation.runsRequired / situation.ballsRemaining > 6 ? 0.8 : 0.5) : 0.6);
        
        // Higher chance of playing big shots when aggressive
        if (Math.random() < aggression * 0.3) {
          return Math.floor(Math.random() * 3) + 4; // 4-6
        } else {
          return Math.floor(Math.random() * 4); // 0-3
        }
      }

      makeBowlingPlay(situation) {
        // More likely to bowl 0 when defending, mix it up otherwise
        if (situation.target && situation.runsRequired < situation.ballsRemaining * 2) {
          return Math.random() < 0.4 ? 0 : Math.floor(Math.random() * 3) + 1;
        }
        return Math.floor(Math.random() * 4); // 0-3
      }
    }

    let aiOpponent = null;
    if (isAIMode) {
      aiOpponent = new AIOpponent('medium');
    }

    const formatRules = {
      "5": { 
        name: "5 Overs", 
        totalOvers: 5, 
        totalWickets: 11, 
        powerplayOvers: 2, 
        powerplayWicketValue: 0.5,
        regularWicketValue: 1.0,
        livesPerPlayer: 2,
        deadOvers: []
      },
      "10": { 
        name: "10 Overs", 
        totalOvers: 10, 
        totalWickets: 11, 
        powerplayOvers: 3, 
        powerplayWicketValue: 0.5,
        regularWicketValue: 1.0,
        livesPerPlayer: 2,
        deadOvers: []
      },
      "20": { 
        name: "T20", 
        totalOvers: 20, 
        totalWickets: 11, 
        powerplayOvers: 6, 
        powerplayWicketValue: 0.5,
        regularWicketValue: 1.0,
        livesPerPlayer: 2,
        deadOvers: []
      },
      "50": { 
        name: "ODI", 
        totalOvers: 50, 
        totalWickets: 11, 
        powerplayOvers: [1,10, 21,30, 41,42], 
        powerplayWicketValue: 0.25,
        regularWicketValue: 0.5,
        livesPerPlayer: 4,
        deadOvers: [11,20, 31,40]
      },
      "test": { 
        name: "Test Match", 
        totalOvers: Infinity, 
        totalWickets: 30, 
        powerplayOvers: 0, 
        powerplayWicketValue: 0.33,
        regularWicketValue: 0.33,
        livesPerPlayer: 3,
        deadOvers: []
      }
    };

    // Game state variables
    let runs = 0, wickets = 0;
    let legalBalls = 0;
    let freeHit = false;
    let freeHitNextBall = false;
    let currentBatter = null;
    let currentBowler = null;
    let battersUsed = [];
    let bowlersUsed = [];
    let bowlerOvers = {};
    let isBatting = false;
    let currentFormat = {};
    let isTestMatch = false;
    let innings = 1;
    let currentInningRuns = 0;
    let currentInningWickets = 0;
    let team1Score = 0;
    let team2Score = 0;
    let team1Wickets = 0;
    let team2Wickets = 0;
    let daysRemaining = 5;
    let oversToday = 0;
    const maxOversPerDay = 90;
    let isPowerplay = false;
    let isDeadOver = false;
    let batterWickets = {};
    let zerosThisOver = { player1: 0, player2: 0 };
    let currentOver = 0;
    let deadOversSelected = [];
    let bowlerRuns = {};
    let gameInProgress = true;
    let lastOverRuns = 0;
    let lastOverWickets = 0;
    let lastWicketScore = 0;
    let ballByBall = {};
    const playerRef = ref(db, `rooms/${room}/${player}/online`);
    const opponentRef = ref(db, `rooms/${room}/${opponent}/online`);
    let playTimeout;
    let batterStats = {};
    let bowlerStats = {};
    let autoStartTimer;
    let countdownInterval;
    let tossWinner = null;
    let battingFirst = null;
    const milestoneLevels = [50, 100, 150, 200, 250, 300, 350, 400];

    // DOM elements
    const statusMessage = document.getElementById("statusMessage");
    const roleText = document.getElementById("roleText");
    const currentBatterEl = document.getElementById("currentBatter");
    const currentBowlerEl = document.getElementById("currentBowler");
    const playerSelectionModal = document.getElementById("playerSelectionModal");
    const selectionTitle = document.getElementById("selectionTitle");
    const playerList = document.getElementById("playerList");
    const confirmPlayerSelection = document.getElementById("confirmPlayerSelection");
    const team1NameEl = document.getElementById("team1Name");
    const team2NameEl = document.getElementById("team2Name");
    const team1PlayersEl = document.getElementById("team1Players");
    const team2PlayersEl = document.getElementById("team2Players");
    const testControls = document.getElementById("testControls");
    const declareBtn = document.getElementById("declareInnings");
    const followOnBtn = document.getElementById("enforceFollowOn");
    const formatDisplay = document.getElementById("formatDisplay");
    const powerplayIndicator = document.getElementById("powerplayIndicator");
    const freeHitIndicator = document.getElementById("freeHitIndicator");
    const deadOverIndicator = document.getElementById("deadOverIndicator");
    const saveBtn = document.getElementById("saveGame");
    const exitBtn = document.getElementById("exitGame");
    const resetPlaysBtn = document.getElementById("resetPlaysBtn");
    const connectionStatus = document.getElementById("connectionStatus");
    const spectatorCountEl = document.getElementById("spectatorCount");
    const targetDisplay = document.getElementById("targetDisplay");
    const targetEl = document.getElementById("target");
    const runsRequiredEl = document.getElementById("runsRequired");
    const ballsRemainingEl = document.getElementById("ballsRemaining");
    const requiredRateEl = document.getElementById("requiredRate");
    const runsEl = document.getElementById("runs");
    const wicketsEl = document.getElementById("wickets");
    const oversEl = document.getElementById("overs");
    const currentRunRateEl = document.getElementById("currentRunRate");
    const lastOverRunsEl = document.getElementById("lastOverRuns");
    const currentInningsEl = document.getElementById("currentInnings");
    const battingTeamNameEl = document.getElementById("battingTeamName");
    const batterStatsEl = document.getElementById("batterStats");
    const bowlerStatsEl = document.getElementById("bowlerStats");
    const batterLivesEl = document.getElementById("batterLives");
    const bowlerOversEl = document.getElementById("bowlerOvers");
    const selectedCardEl = document.getElementById("selectedCard");
    const selectedValueEl = document.querySelector(".selected-value");
    const ballResultEl = document.getElementById("ballResult");
    const playerChoiceEl = document.getElementById("playerChoice");
    const opponentChoiceEl = document.getElementById("opponentChoice");
    const ballOutcomeEl = document.getElementById("ballOutcome");
    const errorModal = document.getElementById("error-modal");
    const errorMessageEl = document.getElementById("error-message");
    const retryBtn = document.getElementById("retry-btn");
    const loadingOverlay = document.getElementById("loading-overlay");
    const roomCodeEl = document.getElementById("roomCode");

    // Helper functions
    function showLoading(message) {
      loadingOverlay.querySelector('p').textContent = message;
      loadingOverlay.style.display = 'flex';
    }

    function hideLoading() {
      loadingOverlay.style.display = 'none';
    }

    function showError(message) {
      errorMessageEl.textContent = message;
      errorModal.style.display = 'flex';
    }

    function hideError() {
      errorModal.style.display = 'none';
    }

    function showNotification(message, type = 'info', duration = 3000) {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, duration);
    }

    function formatOvers(balls) {
      const overs = Math.floor(balls / 6);
      const ballsInOver = balls % 6;
      return `${overs}.${ballsInOver}`;
    }

    function calculateRunRate(runs, balls) {
      if (balls === 0) return '0.00';
      return (runs / (balls / 6)).toFixed(2);
    }

    function calculateRequiredRate(target, currentRuns, ballsRemaining) {
      if (ballsRemaining === 0) return '0.00';
      const requiredRuns = target - currentRuns;
      return (requiredRuns / (ballsRemaining / 6)).toFixed(2);
    }

    function createConfetti() {
      const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
      for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = `${Math.random() * 100}%`;
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.width = `${Math.random() * 10 + 5}px`;
        confetti.style.height = `${Math.random() * 10 + 5}px`;
        confetti.style.animationDuration = `${Math.random() * 3 + 2}s`;
        document.body.appendChild(confetti);
        setTimeout(() => confetti.remove(), 5000);
      }
    }

    function enableButtons() {
      document.querySelectorAll('.card').forEach(btn => btn.disabled = false);
    }

    function disableButtons() {
      document.querySelectorAll('.card').forEach(btn => btn.disabled = true);
    }

    function checkPowerplayStatus() {
      const currentOver = Math.floor(legalBalls / 6);
      
      isPowerplay = false;
      isDeadOver = false;
      
      powerplayIndicator.style.display = "none";
      deadOverIndicator.style.display = "none";

      if (isTestMatch) return;

      if (Array.isArray(currentFormat.powerplayOvers)) {
        for (let i = 0; i < currentFormat.powerplayOvers.length; i += 2) {
          if (currentOver >= currentFormat.powerplayOvers[i] - 1 && 
              currentOver <= currentFormat.powerplayOvers[i+1] - 1) {
            isPowerplay = true;
            powerplayIndicator.style.display = "block";
            break;
          }
        }
      } else if (currentOver < currentFormat.powerplayOvers) {
        isPowerplay = true;
        powerplayIndicator.style.display = "block";
      }

      if (currentFormat.deadOvers?.length > 0) {
        for (let i = 0; i < currentFormat.deadOvers.length; i += 2) {
          if (currentOver >= currentFormat.deadOvers[i] - 1 && 
              currentOver <= currentFormat.deadOvers[i+1] - 1) {
            isDeadOver = true;
            deadOverIndicator.style.display = "block";
            break;
          }
        }
      }

      updateFreeHitDisplay();
    }

    function updateFreeHitDisplay() {
      freeHitIndicator.style.display = freeHit ? "block" : "none";
    }

    function updateScoreboard() {
      const overs = Math.floor(legalBalls / 6);
      const balls = legalBalls % 6;
      
      // Display wickets as whole numbers when batter is out
      const displayWickets = Math.floor(wickets);
      let totalWickets = currentFormat.totalWickets;

      runsEl.textContent = runs;
      wicketsEl.textContent = displayWickets;
      oversEl.textContent = `${overs}.${balls}`;
      currentRunRateEl.textContent = calculateRunRate(runs, legalBalls);

      if (isTestMatch) {
        currentInningsEl.textContent = `Innings ${innings} | Day ${6 - daysRemaining}`;
      } else {
        currentInningsEl.textContent = `${innings}${innings === 1 ? 'st' : 'nd'} Innings`;
      }

      if (innings === 2) {
        targetDisplay.style.display = "block";
        targetEl.textContent = team1Score + 1;
        
        const ballsRemaining = currentFormat.totalOvers * 6 - legalBalls;
        runsRequiredEl.textContent = Math.max(0, team1Score - runs + 1);
        ballsRemainingEl.textContent = ballsRemaining;
        requiredRateEl.textContent = calculateRequiredRate(team1Score + 1, runs, ballsRemaining);
      } else {
        targetDisplay.style.display = "none";
      }

      checkPowerplayStatus();
    }

    function updateCurrentPlayers() {
      if (currentBatter) {
        currentBatterEl.textContent = currentBatter;
        const stats = batterStats[currentBatter] || { runs: 0, balls: 0 };
        batterStatsEl.textContent = `${stats.runs}(${stats.balls})`;
        
        // Show batter lives
        const livesLeft = 1 - (batterWickets[currentBatter] || 0);
        batterLivesEl.innerHTML = '';
        for (let i = 0; i < Math.ceil(livesLeft); i++) {
          batterLivesEl.innerHTML += '❤️';
        }
      }
      
      if (currentBowler) {
        currentBowlerEl.textContent = currentBowler;
        const stats = bowlerStats[currentBowler] || { runs: 0, wickets: 0, overs: 0 };
        bowlerStatsEl.textContent = `${stats.overs}-${stats.maidens || 0}-${stats.runs}-${stats.wickets}`;
      }
    }

    function updatePlayingXI() {
      // Update player status in team lists
      document.querySelectorAll('.player-item').forEach(item => {
        item.classList.remove('current-batter', 'current-bowler', 'out');
        
        if (item.textContent === currentBatter) {
          item.classList.add('current-batter');
        } else if (item.textContent === currentBowler) {
          item.classList.add('current-bowler');
        } else if (batterWickets[item.textContent] >= 1) {
          item.classList.add('out');
        }
      });
    }

    function showBallResult(playerChoice, opponentChoice, outcome) {
      playerChoiceEl.textContent = playerChoice;
      opponentChoiceEl.textContent = opponentChoice;
      ballOutcomeEl.textContent = outcome;
      ballResultEl.style.display = 'block';
      
      setTimeout(() => {
        ballResultEl.style.display = 'none';
      }, 3000);
    }

    async function resetPlays() {
      try {
        await update(ref(db, `rooms/${room}`), {
          'currentPlays/player1': null,
          'currentPlays/player2': null
        });
        enableButtons();
      } catch (error) {
        showError('Failed to reset plays: ' + error.message);
      }
    }

    async function declareInnings() {
      if (confirm('Are you sure you want to declare this innings?')) {
        try {
          await set(ref(db, `rooms/${room}/declared`), true);
          endInning();
          showNotification('Innings declared!', 'success');
        } catch (error) {
          showError('Failed to declare innings: ' + error.message);
        }
      }
    }

    async function enforceFollowOn() {
      if (confirm('Are you sure you want to enforce follow-on?')) {
        try {
          await set(ref(db, `rooms/${room}/followOn`), true);
          innings = 2;
          resetInning();
          showNotification('Follow-on enforced!', 'success');
        } catch (error) {
          showError('Failed to enforce follow-on: ' + error.message);
        }
      }
    }

    async function saveGame() {
      try {
        showLoading('Saving game...');
        
        const gameState = {
          timestamp: Date.now(),
          players: {
            player1: { 
              team: team1NameEl.textContent,
              score: team1Score 
            },
            player2: { 
              team: team2NameEl.textContent,
              score: team2Score 
            }
          },
          innings: innings,
          currentBatter: currentBatter,
          currentBowler: currentBowler,
          ballsRemaining: currentFormat.totalOvers * 6 - legalBalls,
          batterWickets: batterWickets,
          bowlerOvers: bowlerOvers,
          runs: runs,
          wickets: wickets,
          currentInningRuns: currentInningRuns,
          currentInningWickets: currentInningWickets,
          batterStats: batterStats,
          bowlerStats: bowlerStats
        };
        
        await set(ref(db, `savedGames/${room}`), gameState);
        await set(playerRef, false);
        showNotification('Game saved successfully!', 'success');
        window.location.href = "index.html";
      } catch (error) {
        showError('Failed to save game: ' + error.message);
      } finally {
        hideLoading();
      }
    }

    async function exitGame() {
      if (confirm('Are you sure you want to exit? Unsaved progress will be lost.')) {
        gameInProgress = false;
        await set(playerRef, false);
        window.location.href = "index.html";
      }
    }

    function viewScoreboard() {
      window.open(`scoreboard.html?room=${room}`, '_blank');
    }

    function handleBeforeUnload(event) {
      if (gameInProgress) {
        event.preventDefault();
        event.returnValue = 'Game is in progress. Are you sure you want to leave?';
        return event.returnValue;
      }
    }

    function endInning() {
      if (innings === 1) {
        team1Score = currentInningRuns;
        team1Wickets = wickets;
        showNotification(`Team 1 scored ${team1Score} runs!`, 'success');
        
        if (!isTestMatch) {
          statusMessage.textContent = `Team 1 scored ${team1Score} runs! Starting second innings...`;
          setTimeout(() => {
            innings++;
            resetInning();
          }, 3000);
        }
      } else {
        team2Score = currentInningRuns;
        team2Wickets = wickets;
        showNotification(`Team 2 scored ${team2Score} runs!`, 'success');
      }
      
      updateScoreboard();
    }

    function resetInning() {
      runs = 0;
      wickets = 0;
      currentInningRuns = 0;
      currentInningWickets = 0;
      legalBalls = 0;
      oversToday = 0;
      battersUsed = [];
      bowlerOvers = {};
      batterWickets = {};
      freeHit = false;
      freeHitNextBall = false;
      currentBatter = null;
      currentBowler = null;
      zerosThisOver = { player1: 0, player2: 0 };
      
      // Clear current plays
      set(ref(db, `rooms/${room}/currentPlays`), { player1: null, player2: null });
      
      // Toggle batting role based on innings
      isBatting = (innings % 2 === 1) ? (player === battingFirst) : (player !== battingFirst);
      
      // Update role text
      roleText.textContent = isBatting ? 
        `You are Batting` : 
        `You are Bowling`;
      
      if (isBatting) {
        showBatterSelection();
      } else {
        showBowlerSelection();
      }
      
      updateScoreboard();
      updateCurrentPlayers();
      updatePlayingXI();
    }

    function endMatch() {
      let result = "";
      let winner = "";
      let winMargin = 0;
      
      if (isTestMatch) {
        if (team1Score > team2Score) {
          winMargin = team1Score - team2Score;
          result = `Team 1 wins by ${winMargin} runs`;
          winner = "player1";
        } else if (team2Score > team1Score) {
          winMargin = 10 - Math.floor(team2Wickets);
          result = `Team 2 wins by ${winMargin} wickets`;
          winner = "player2";
        } else {
          result = "Match drawn";
        }
      } else {
        if (innings === 2) {
          if (team2Score > team1Score) {
            winMargin = currentFormat.totalWickets - Math.floor(team2Wickets);
            result = `Team 2 wins by ${winMargin} wickets`;
            winner = "player2";
          } else if (team1Score > team2Score) {
            winMargin = team1Score - team2Score;
            result = `Team 1 wins by ${winMargin} runs`;
            winner = "player1";
          } else {
            result = "Match tied";
          }
        } else {
          winMargin = currentFormat.totalWickets - Math.floor(team1Wickets);
          result = `Team 1 wins by ${winMargin} wickets`;
          winner = "player1";
        }
      }
      
      // Show winner notification with celebration
      if (winner) {
        const winnerName = winner === "player1" ? 
          team1NameEl.textContent : 
          team2NameEl.textContent;
          
        showNotification(`${winnerName} wins the match! 🏆`, 'success');
        createConfetti();
        
        // Highlight winning team in scoreboard
        if (winner === "player1") {
          team1NameEl.classList.add('team-winner');
          team1PlayersEl.classList.add('team-winner');
        } else {
          team2NameEl.classList.add('team-winner');
          team2PlayersEl.classList.add('team-winner');
        }
      }
      
      statusMessage.textContent = `Match Over! ${result}`;
      disableButtons();
      set(ref(db, `rooms/${room}/result`), result);
      
      // Redirect to results page after delay
      setTimeout(() => {
        window.location.href = `result.html?room=${room}&player=${player}&winner=${winner}&result=${encodeURIComponent(result)}`;
      }, 5000);
    }

    async function showBatterSelection() {
      disableButtons();
      try {
        const snapshot = await get(ref(db, `rooms/${room}/${player}/playing11`));
        const players = snapshot.val();
        
        const availableBatters = players.filter(p => 
          !battersUsed.includes(p) || 
          (batterWickets[p] !== undefined && batterWickets[p] < 1.0)
        );
        
        if (availableBatters.length === 0) {
          showNotification("All batters are out!", 'warning');
          return;
        }

        showPlayerSelection(availableBatters, 'batter');
      } catch (error) {
        showError('Batter selection error: ' + error.message);
      }
    }

    async function showBowlerSelection() {
      disableButtons();
      try {
        const snapshot = await get(ref(db, `rooms/${room}/${player}/playing11`));
        const players = snapshot.val();
        const maxOversPerBowler = isTestMatch ? Infinity : Math.ceil(currentFormat.totalOvers / 5);
        const availableBowlers = players.filter(p => (bowlerOvers[p] || 0) < maxOversPerBowler);
        
        if (availableBowlers.length === 0) {
          showNotification("All bowlers have bowled their maximum overs!", 'warning');
          return;
        }

        showPlayerSelection(availableBowlers, 'bowler');
      } catch (error) {
        showError('Bowler selection error: ' + error.message);
      }
    }

    function showPlayerSelection(players, role) {
      selectionTitle.textContent = `Select Next ${role === 'batter' ? 'Batter' : 'Bowler'}`;
      playerList.innerHTML = '';
      
      players.forEach(player => {
        const playerOption = document.createElement('div');
        playerOption.className = 'player-option';
        playerOption.textContent = player;
        playerOption.addEventListener('click', () => {
          document.querySelectorAll('.player-option').forEach(opt => opt.classList.remove('selected'));
          playerOption.classList.add('selected');
        });
        playerList.appendChild(playerOption);
      });
      
      playerSelectionModal.style.display = 'flex';
    }

    confirmPlayerSelection.addEventListener('click', async () => {
      const selectedPlayer = document.querySelector('.player-option.selected');
      if (!selectedPlayer) {
        showNotification('Please select a player', 'warning');
        return;
      }
      
      try {
        if (isBatting) {
          currentBatter = selectedPlayer.textContent;
          await set(ref(db, `rooms/${room}/currentBatter`), currentBatter);
          if (!battersUsed.includes(currentBatter)) {
            battersUsed.push(currentBatter);
            batterWickets[currentBatter] = 0;
          }
        } else {
          currentBowler = selectedPlayer.textContent;
          await set(ref(db, `rooms/${room}/currentBowler`), currentBowler);
        }
        
        playerSelectionModal.style.display = 'none';
        enableButtons();
        updateCurrentPlayers();
        updatePlayingXI();
        statusMessage.textContent = isBatting ? 'Select your batting number' : 'Select your bowling number';
      } catch (error) {
        showError('Failed to select player: ' + error.message);
      }
    });

    // Card selection event listeners
    document.querySelectorAll('.card').forEach(card => {
      card.addEventListener('click', async () => {
        const value = parseInt(card.dataset.value);
        
        // Disable buttons while processing
        disableButtons();
        
        // Show selected card
        selectedValueEl.textContent = value;
        selectedCardEl.style.display = 'block';
        
        try {
          // Save player's play
          await set(ref(db, `rooms/${room}/currentPlays/${player}`), value);
          
          // If AI mode, make AI play immediately
          if (isAIMode) {
            const currentSituation = {
              isBatting: player === battingFirst,
              runs: runs,
              wickets: wickets,
              overs: legalBalls / 6,
              target: innings === 2 ? team1Score + 1 : null,
              runsRequired: innings === 2 ? (team1Score + 1 - runs) : null,
              ballsRemaining: currentFormat.totalOvers * 6 - legalBalls,
              isPowerplay: isPowerplay,
              isDeadOver: isDeadOver,
              currentBatter: currentBatter,
              currentBowler: currentBowler
            };
            
            const aiPlay = aiOpponent.makePlay(currentSituation);
            
            // Small delay to simulate thinking
            setTimeout(async () => {
              await set(ref(db, `rooms/${room}/currentPlays/${opponent}`), aiPlay);
            }, 1000 + Math.random() * 1000);
          }
        } catch (error) {
          showError('Failed to save your play: ' + error.message);
          enableButtons();
        }
      });
    });

    async function loadGameState() {
      try {
        // Load toss winner and decision
        const tossSnap = await get(ref(db, `rooms/${room}/tossWinner`));
        tossWinner = tossSnap.val();
        
        const decisionSnap = await get(ref(db, `rooms/${room}/decision`));
        const decision = decisionSnap.val();
        
        battingFirst = decision === 'bat' ? tossWinner : (tossWinner === "player1" ? "player2" : "player1");
        
        // Set initial batting role
        isBatting = (player === battingFirst);
        roleText.textContent = isBatting ? 
          `You are Batting (${decision === 'bat' ? 'chose to bat' : 'chose to bowl'})` : 
          `You are Bowling (${decision === 'bowl' ? 'chose to bowl' : 'chose to bat'})`;
        
        // Load format
        const formatSnap = await get(ref(db, `rooms/${room}/player1/format`));
        const format = formatSnap.val() || "5";
        currentFormat = formatRules[format];
        isTestMatch = format === "test";
        formatDisplay.textContent = `Match Format: ${currentFormat.name}`;
        
        // Load teams
        const team1Snap = await get(ref(db, `rooms/${room}/player1/playing11`));
        const team2Snap = await get(ref(db, `rooms/${room}/player2/playing11`));
        
        team1NameEl.textContent = `Team ${player === "player1" ? "1 (You)" : "1"}`;
        team2NameEl.textContent = `Team ${player === "player2" ? "2 (You)" : "2"}`;
        
        team1PlayersEl.innerHTML = '';
        team2PlayersEl.innerHTML = '';
        
        team1Snap.val().forEach(player => {
          const li = document.createElement('li');
          li.className = 'player-item';
          li.textContent = player;
          team1PlayersEl.appendChild(li);
        });
        
        team2Snap.val().forEach(player => {
          const li = document.createElement('li');
          li.className = 'player-item';
          li.textContent = player;
          team2PlayersEl.appendChild(li);
        });
        
        // Initialize stats
        initializeBatterStats();
        
        // Show initial player selection
        if (isBatting) {
          showBatterSelection();
        } else {
          showBowlerSelection();
        }
        
        // Show test controls if test match
        testControls.style.display = isTestMatch ? 'flex' : 'none';
      } catch (error) {
        showError('Failed to load game state: ' + error.message);
      }
    }

    function initializeBatterStats() {
      // Initialize for player1's team
      if (team1PlayersEl.children.length > 0) {
        Array.from(team1PlayersEl.children).forEach(playerEl => {
          const player = playerEl.textContent;
          batterStats[player] = { runs: 0, balls: 0 };
          batterWickets[player] = 0;
          milestoneLevels.forEach(level => {
            batterStats[player][`milestone${level}Notified`] = false;
          });
        });
      }
      
      // Initialize for player2's team
      if (team2PlayersEl.children.length > 0) {
        Array.from(team2PlayersEl.children).forEach(playerEl => {
          const player = playerEl.textContent;
          batterStats[player] = { runs: 0, balls: 0 };
          batterWickets[player] = 0;
          milestoneLevels.forEach(level => {
            batterStats[player][`milestone${level}Notified`] = false;
          });
        });
      }
    }

    function checkBattingMilestones() {
      if (!currentBatter) return;

      const batterRuns = batterStats[currentBatter]?.runs || 0;
      
      for (const milestone of milestoneLevels) {
        if (batterRuns >= milestone && 
            !batterStats[currentBatter][`milestone${milestone}Notified`]) {
          
          const isPlayingXI = (
            team1PlayersEl.textContent.includes(currentBatter) ||
            team2PlayersEl.textContent.includes(currentBatter)
          );
          
          if (isPlayingXI) {
            showNotification(`${currentBatter} scores ${milestone} runs! 🎉`, 'success');
            batterStats[currentBatter][`milestone${milestone}Notified`] = true;
            
            if (milestone >= 150) {
              createConfetti();
            }
            break;
          }
        }
      }
    }

    function checkMilestones() {
      if (currentBatter && batterStats[currentBatter]?.runs >= 100 && 
          !batterStats[currentBatter].centuryNotified) {
        showNotification(`${currentBatter} scores a century! 🎉`, 'success');
        batterStats[currentBatter].centuryNotified = true;
        createConfetti();
      }
      if (currentBowler && bowlerStats[currentBowler]?.wickets >= 5 && 
          !bowlerStats[currentBowler].fiveWicketNotified) {
        showNotification(`${currentBowler} takes 5 wickets! 🎯`, 'success');
        bowlerStats[currentBowler].fiveWicketNotified = true;
        createConfetti();
      }
    }

    async function setupFirebaseListeners() {
      // Set player online status
      set(playerRef, true);
      
      // Monitor opponent connection
      onValue(opponentRef, (snap) => {
        if (!snap.exists() || !snap.val()) {
          connectionStatus.textContent = "Opponent: Offline (Game Paused)";
          connectionStatus.className = "connection-status offline";
          disableButtons();
        } else {
          connectionStatus.textContent = "Opponent: Online";
          connectionStatus.className = "connection-status online";
          if (playerSelectionModal.style.display !== 'flex') {
            enableButtons();
          }
        }
      });
      
      // Room code display
      roomCodeEl.textContent = `Room: ${room}`;
      
      // Spectator count
      onValue(ref(db, `rooms/${room}/spectators`), (snap) => {
        const spectators = snap.val() || {};
        spectatorCountEl.textContent = `👥 ${Object.keys(spectators).length}`;
      });

      // Current plays listener
      onValue(ref(db, `rooms/${room}/currentPlays`), async (snap) => {
        const plays = snap.val();
        
        if (!plays || plays.player1 === undefined || plays.player2 === undefined) {
          return;
        }

        if (plays.player1 === null || plays.player2 === null) {
          return;
        }

        // First check connection status
        const connectionSnap = await get(ref(db, `rooms/${room}/${opponent}/online`));
        if (!connectionSnap.exists() || !connectionSnap.val()) {
          statusMessage.textContent = "Opponent disconnected. Waiting...";
          return;
        }

        const battingPlayer = innings % 2 === 1 ? battingFirst : (battingFirst === "player1" ? "player2" : "player1");
        const bowlingPlayer = battingPlayer === "player1" ? "player2" : "player1";

        const batCard = plays[battingPlayer];
        const bowlCard = plays[bowlingPlayer];

        let outcome = "";
        let isLegalBall = false;
        let isWicket = false;
        let isPlayerOut = false;
        let runsScored = 0;

        if (batCard === 0) zerosThisOver[battingPlayer]++;
        if (bowlCard === 0) zerosThisOver[bowlingPlayer]++;

        // Check for free hit next ball
        if (freeHitNextBall) {
          freeHit = true;
          freeHitNextBall = false;
          updateFreeHitDisplay();
        }

        if (batCard === 0 && bowlCard === 0) {
          if (!isTestMatch) {
            outcome = "NO BALL! +1 run (Free Hit next ball)";
            runs += 1;
            currentInningRuns += 1;
            freeHitNextBall = true;
            isLegalBall = false;
          } else {
            outcome = "No run (Test Match)";
          }
        } 
        else if (freeHit) {
          // Handle free hit ball
          if (batCard === bowlCard && batCard > 0) {
            outcome = "Wicket on Free Hit (not out)";
            isWicket = false;
          } else {
            runsScored = batCard;
            runs += batCard;
            currentInningRuns += batCard;
            outcome = `${batCard} Run(s)! (Free Hit)`;
          }
          freeHit = false;
          updateFreeHitDisplay();
          isLegalBall = true;
        }
        else if (batCard === bowlCard && batCard > 0) {
          // Wicket logic with fractional wickets
          let wicketValue;
          if (isTestMatch) {
            wicketValue = 0.33;
          } 
          else if (currentFormat.name === "ODI") {
            wicketValue = isPowerplay ? 0.25 : 0.5;
          }
          else {
            wicketValue = isPowerplay ? 0.5 : 1.0;
          }
          
          // Track fractional wickets per batter
          if (!batterWickets[currentBatter]) {
            batterWickets[currentBatter] = 0;
          }
          
          batterWickets[currentBatter] += wicketValue;
          wickets += wicketValue;
          
          // Check if batter is out (reached 1.0 wicket)
          if (batterWickets[currentBatter] >= 1.0) {
            isPlayerOut = true;
            outcome = "WICKET! (Out)";
            // Round up to whole number for display
            wickets = Math.ceil(wickets);
          } else {
            outcome = `WICKET! (${(1.0 - batterWickets[currentBatter]).toFixed(2)} wickets left)`;
          }
          
          isLegalBall = true;
          isWicket = true;
        }
        else if (batCard === 0 && bowlCard > 0) {
          if (zerosThisOver[battingPlayer] > 3) {
            runs -= 5;
            outcome = "4th 0 in over! -5 runs";
          } else {
            if (isTestMatch) {
              bowlerRuns[currentBowler] = (bowlerRuns[currentBowler] || 0) + bowlCard;
              outcome = `Bowler's ${bowlCard} runs added to their stats`;
            } else {
              runsScored = bowlCard;
              runs += bowlCard;
              currentInningRuns += bowlCard;
              outcome = `Batter played 0. Runs = ${bowlCard}`;
            }
          }
          isLegalBall = true;
        }
        else if (bowlCard === 0 && batCard > 0) {
          if (zerosThisOver[bowlingPlayer] > 3 && !isTestMatch) {
            outcome = "4th 0 in over! No ball";
            runs += 1;
            freeHitNextBall = true;
          } else {
            if (isTestMatch) {
              runsScored = batCard;
              runs += batCard;
              currentInningRuns += batCard;
              outcome = `${batCard} Run(s)!`;
            } else {
              outcome = "DOT BALL!";
            }
          }
          isLegalBall = true;
        }
        else {
          runsScored = batCard;
          runs += batCard;
          currentInningRuns += batCard;
          outcome = `${batCard} Run(s)!`;
          isLegalBall = true;
        }

        // Update player stats
        if (currentBatter && runsScored > 0) {
          batterStats[currentBatter] = batterStats[currentBatter] || { runs: 0, balls: 0 };
          batterStats[currentBatter].runs += runsScored;
          batterStats[currentBatter].balls += 1;
        }
        
        if (currentBowler && isWicket) {
          bowlerStats[currentBowler] = bowlerStats[currentBowler] || { wickets: 0, runs: 0, overs: 0 };
          bowlerStats[currentBowler].wickets += 1;
        }

        // Record ball data
        ballByBall[legalBalls] = {
          runs: batCard,
          wicket: isWicket || isPlayerOut,
          batter: currentBatter,
          bowler: currentBowler,
          timestamp: Date.now()
        };

        if (isWicket) {
          lastWicketScore = runs;
        }

        if (isLegalBall) {
          legalBalls++;
          if (isTestMatch) oversToday++;
          
          if (currentBowler) {
            bowlerOvers[currentBowler] = (bowlerOvers[currentBowler] || 0) + (1/6);
            if (legalBalls % 6 === 0) {
              bowlerOvers[currentBowler] = Math.round(bowlerOvers[currentBowler] * 10) / 10;
              zerosThisOver = { player1: 0, player2: 0 };
            }
          }
          
          if (isTestMatch && oversToday >= maxOversPerDay) {
            endDaysPlay();
            return;
          }
        }

        statusMessage.textContent = outcome;
        showBallResult(
          player === battingPlayer ? batCard : bowlCard,
          player === battingPlayer ? bowlCard : batCard,
          outcome
        );
        
        updateScoreboard();
        updateCurrentPlayers();
        updatePlayingXI();
        checkMilestones();
        checkBattingMilestones();
        
        // Check for match completion
        if (innings === 2 && runs > team1Score) {
          endMatch();
          return;
        }
        
        if ((isTestMatch && currentInningWickets >= 30) || 
            (!isTestMatch && (wickets >= currentFormat.totalWickets || legalBalls >= currentFormat.totalOvers * 6))) {
          endInning();
          return;
        }

        setTimeout(async () => {
          await resetPlays();
          
          if ((isPlayerOut || isWicket) && player === battingPlayer) {
            showBatterSelection();
          } else if (isLegalBall && legalBalls % 6 === 0 && player === bowlingPlayer) {
            showBowlerSelection();
          } else {
            statusMessage.textContent = freeHit ? "FREE HIT! Play your next card." : "Play your next card.";
            enableButtons();
          }
        }, 1500);
      });

      // Current batter listener
      onValue(ref(db, `rooms/${room}/currentBatter`), (snap) => {
        const batter = snap.val();
        if (batter && batter !== currentBatter) {
          currentBatter = batter;
          currentBatterEl.textContent = batter;
          if (!battersUsed.includes(batter)) {
            battersUsed.push(batter);
            if (batterWickets[batter] === undefined) {
              batterWickets[batter] = 0;
            }
          }
        }
      });

      // Current bowler listener
      onValue(ref(db, `rooms/${room}/currentBowler`), (snap) => {
        const bowler = snap.val();
        if (bowler && bowler !== currentBowler) {
          currentBowler = bowler;
          currentBowlerEl.textContent = bowler;
        }
      });

      // Follow-on listener
      onValue(ref(db, `rooms/${room}/followOn`), (snap) => {
        const followOn = snap.val();
        followOnBtn.style.display = followOn ? "block" : "none";
      });

      // Live reactions listener
      onValue(ref(db, `rooms/${room}/reactions`), (snap) => {
        const reactions = snap.val();
        if (!reactions) return;
        const lastReaction = Object.values(reactions).pop();
        if (lastReaction.player !== player) {
          const reactionEl = document.createElement('div');
          reactionEl.textContent = lastReaction.emoji;
          reactionEl.style.position = 'fixed';
          reactionEl.style.fontSize = '48px';
          reactionEl.style.animation = 'fadeInOut 2s';
          reactionEl.style.zIndex = '999';
          reactionEl.style.left = `${Math.random() * 70 + 15}%`;
          reactionEl.style.top = `${Math.random() * 70 + 15}%`;
          document.body.appendChild(reactionEl);
          setTimeout(() => reactionEl.remove(), 2000);
        }
      });
    }

    function endDaysPlay() {
      disableButtons();
      statusMessage.textContent = "Stumps for the day!";
      daysRemaining--;
      
      setTimeout(() => {
        if (daysRemaining > 0) {
          oversToday = 0;
          enableButtons();
          statusMessage.textContent = `Day ${6 - daysRemaining} starting...`;
          updateScoreboard();
        } else {
          endMatch();
        }
      }, 3000);
    }

    // Initialize the game
    async function initGame() {
      try {
        showLoading('Loading match...');
        
        // Load game state
        await loadGameState();
        
        // Setup event listeners
        setupEventListeners();
        
        // Initialize Firebase listeners
        setupFirebaseListeners();
        
        hideLoading();
      } catch (error) {
        showError('Failed to initialize game: ' + error.message);
      }
    }

    function setupEventListeners() {
      // Game control buttons
      saveBtn.addEventListener('click', saveGame);
      exitBtn.addEventListener('click', exitGame);
      resetPlaysBtn.addEventListener('click', resetPlays);
      declareBtn.addEventListener('click', declareInnings);
      followOnBtn.addEventListener('click', enforceFollowOn);
      
      // Before unload handler
      window.addEventListener('beforeunload', handleBeforeUnload);
    }

    // Start the game
    initGame();
  </script>
</body>
        </html>
