<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HandiCricket - Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { background: #061e3e; color: white; font-family: sans-serif; text-align: center; padding: 20px; }
    .card-row { margin-top: 20px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
    button.card { width: 60px; height: 60px; font-size: 20px; border-radius: 12px; border: none; background: #1e88e5; color: white; }
    button.card:disabled { background: #607d8b; color: #ccc; }
    #scoreboard, #roleText { margin-top: 10px; font-size: 18px; }
    #status { margin-top: 15px; font-size: 16px; color: #ffeb3b; }
    .free-hit-indicator {
      background: #4CAF50;
      color: white;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 12px;
      margin-left: 10px;
      display: inline-block;
    }
    .powerplay-indicator {
      background: #ffeb3b;
      color: #000;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 12px;
      margin-left: 10px;
      display: inline-block;
    }
    .dead-over {
      background: #f44336;
      color: white;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 12px;
    }
    .selection-modal { 
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
      background: rgba(0,0,0,0.8); display: flex; justify-content: center; 
      align-items: center; z-index: 100; 
    }
    .selection-box { 
      background: #123456; padding: 20px; border-radius: 10px; 
      width: 300px; max-width: 90%; 
    }
    .selection-list { 
      max-height: 300px; overflow-y: auto; margin: 15px 0; 
      text-align: left; 
    }
    .player-item { 
      padding: 8px; margin: 5px 0; background: #1e88e5; 
      border-radius: 5px; cursor: pointer; 
    }
    .player-item:hover { background: #1565c0; }
    .player-item.selected { background: #0d47a1; }
    .test-controls { 
      margin: 15px 0; 
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .test-controls button {
      padding: 10px 15px;
      font-size: 14px;
      background: #ff9800;
    }
    .test-controls button:hover {
      background: #f57c00;
    }
    .innings-display {
      background: #0d2a52;
      padding: 10px;
      border-radius: 8px;
      margin: 10px 0;
      text-align: left;
    }
    #formatDisplay {
      font-weight: bold;
      color: #4caf50;
      margin-bottom: 10px;
    }
    #teamStatus {
      margin: 15px 0;
      padding: 10px;
      background: #0d2a52;
      border-radius: 8px;
    }
    #specialAlerts {
      margin: 10px 0;
    }
    .alert {
      display: none;
      padding: 10px;
      margin: 5px;
      border-radius: 5px;
      font-weight: bold;
      text-align: center;
    }
    #powerplayAlert { background: yellow; color: black; }
    #freeHitAlert { background: green; color: white; }
    #deadOverAlert { background: red; color: white; }
    #gameControls {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      justify-content: center;
    }
    #connectionStatus {
      padding: 8px;
      border-radius: 5px;
      text-align: center;
      margin: 10px auto;
      max-width: 400px;
    }
    .online { background: #4CAF50; }
    .offline { background: #F44336; }
    #saveBtn { background: #FF9800; }
    #saveBtn:hover { background: #F57C00; }
    #exitBtn { background: #f44336; }
    #exitBtn:hover { background: #d32f2f; }
    #resetPlaysBtn { background: #9c27b0; }
    #resetPlaysBtn:hover { background: #7b1fa2; }
    #spectatorCount {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #1e88e5;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 14px;
    }
    #targetDisplay {
      margin: 15px 0;
      padding: 10px;
      background: #0d2a52;
      border-radius: 8px;
      font-weight: bold;
    }
    /* Enhanced batter selection styles */
    .batter-stats {
      font-size: 0.8em;
      color: #aaa;
      margin-top: 3px;
    }
    
    .batter-item {
      display: flex;
      flex-direction: column;
      padding: 10px;
      margin: 5px 0;
      background: #1e88e5;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .batter-item:hover {
      background: #1565c0;
      transform: translateX(5px);
    }
    
    .batter-item.selected {
      background: #0d47a1;
      border-left: 4px solid #ffeb3b;
    }
    
    .batter-status {
      display: flex;
      justify-content: space-between;
      margin-top: 5px;
      font-size: 0.8em;
    }
    
    .batter-runs {
      color: #4CAF50;
    }
    
    .batter-balls {
      color: #FFC107;
    }
    
    .batter-sr {
      color: #9C27B0;
    }
    
    .wickets-left {
      color: #F44336;
      font-weight: bold;
    }
    /* Enhanced bowler selection styles */
    .bowler-stats {
      font-size: 0.8em;
      color: #aaa;
      margin-top: 3px;
    }
    /* Spectator features */
    #spectatorEngagement {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 10px;
      z-index: 100;
    }
    #liveReactions span {
      font-size: 24px;
      margin: 0 5px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    #liveReactions span:hover {
      transform: scale(1.2);
    }
    .meter-bar {
      height: 10px;
      background: linear-gradient(to right, #f44336, #ffeb3b, #4CAF50);
      width: 100%;
      border-radius: 5px;
      margin-top: 8px;
    }
    #miniScorecard {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 100;
      display: flex;
      gap: 10px;
    }
    /* Milestone notification styles */
    .milestone-notification {
      position: fixed;
      bottom: 20%;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      padding: 12px 24px;
      border-radius: 24px;
      animation: fadeInOut 3s;
      z-index: 1000;
      font-weight: bold;
      text-align: center;
      min-width: 300px;
      font-size: 1.2em;
      border: 2px solid white;
    }
    /* Different styles for different notification types */
    .milestone-notification.batting {
      background: linear-gradient(135deg, #006400, #228B22);
      box-shadow: 0 0 20px lime;
    }
    .milestone-notification.bowling {
      background: linear-gradient(135deg, #8B0000, #B22222);
      box-shadow: 0 0 20px red;
    }
    .milestone-notification.winner {
      background: linear-gradient(135deg, #FFD700, #DAA520);
      box-shadow: 0 0 30px gold;
      font-size: 1.5em;
      padding: 15px 30px;
    }
    .milestone-notification.info {
      background: rgba(0, 0, 139, 0.9);
      box-shadow: 0 0 15px blue;
    }
    /* Winner team highlight */
    .team-winner {
      color: gold !important;
      text-shadow: 0 0 10px gold;
      animation: pulse 1s infinite alternate;
    }
    @keyframes pulse {
      from { transform: scale(1); }
      to { transform: scale(1.05); }
    }
    @keyframes fadeInOut {
      0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
      10% { opacity: 1; transform: translateX(-50%) translateY(0); }
      90% { opacity: 1; transform: translateX(-50%) translateY(0); }
      100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
    }
    .required-rate {
      color: #ff9800;
      font-weight: bold;
    }
    /* New styles for innings transition */
    #startInningsBtn {
      margin: 20px auto;
      padding: 12px 24px;
      font-size: 18px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      display: none;
      transition: all 0.3s;
    }
    #startInningsBtn:hover {
      background: #45a049;
      transform: scale(1.05);
    }
    #startInningsBtn:disabled {
      background: #607d8b;
      cursor: not-allowed;
    }
    .transition-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      flex-direction: column;
      animation: fadeIn 0.5s;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .transition-message {
      font-size: 24px;
      margin-bottom: 20px;
      color: white;
      text-align: center;
    }
    .transition-countdown {
      font-size: 48px;
      font-weight: bold;
      color: #4CAF50;
      margin: 20px 0;
    }
    .opponent-ready {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 15px;
      color: #4CAF50;
      font-weight: bold;
    }
    .opponent-ready span {
      margin-left: 10px;
    }
    .ready-checkmark {
      color: #4CAF50;
      font-size: 24px;
    }
    .auto-start-timer {
      margin-top: 15px;
      font-size: 16px;
      color: #ff9800;
    }
    /* Confetti styles */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background-color: #f00;
      opacity: 0;
      animation: confetti-fall 5s ease-in-out forwards;
      z-index: 999;
    }
    @keyframes confetti-fall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div id="spectatorCount">Spectators: 0</div>
  <div id="miniScorecard">
    <div id="miniScore">0/0</div>
    <div id="miniOvers">0.0</div>
  </div>
  
  <h2>üèè HandiCricket - Game</h2>
  <div id="formatDisplay"></div>
  <div id="roleText"></div>
  <div id="teamStatus">
    <div id="currentPlayers" style="font-weight: bold; font-size: 16px;">
      Batter: <span id="currentBatter">-</span> | Bowler: <span id="currentBowler">-</span>
    </div>
    <div id="scoreboard">Runs: 0 | Wickets: 0 | Overs: 0.0</div>
  </div>
  
  <div id="targetDisplay" style="display: none;">
    <div class="target-text">Target: <span id="targetRuns">0</span> runs | <span id="requiredRate" class="required-rate">RR: 0.00</span></div>
  </div>
  
  <div id="specialAlerts">
    <div id="powerplayAlert" class="alert">POWERPLAY</div>
    <div id="freeHitAlert" class="alert">FREE HIT</div>
    <div id="deadOverAlert" class="alert">DEAD OVER</div>
  </div>
  <div id="freeHitIndicator" class="free-hit-indicator" style="display:none;">FREE HIT</div>
  <div id="status">Waiting for players...</div>

  <div id="testControls" class="test-controls" style="display: none;">
    <button id="declareInning">Declare Innings</button>
    <button id="enforceFollowOn" style="display: none;">Enforce Follow-On</button>
  </div>

  <div class="card-row" id="cardButtons">
    <button class="card" data-value="0">0</button>
    <button class="card" data-value="1">1</button>
    <button class="card" data-value="2">2</button>
    <button class="card" data-value="3">3</button>
    <button class="card" data-value="4">4</button>
    <button class="card" data-value="5">5</button>
    <button class="card" data-value="6">6</button>
  </div>

  <!-- Enhanced Start Innings Button -->
  <button id="startInningsBtn">
    <div id="startInningsText">Start Second Innings</div>
    <div id="opponentReadyStatus" class="opponent-ready" style="display: none;">
      <span class="ready-checkmark">‚úì</span>
      <span>Opponent Ready</span>
    </div>
    <div id="autoStartTimer" class="auto-start-timer" style="display: none;"></div>
  </button>

  <div id="playingXISection" style="margin-top: 30px;">
    <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
      <div>
        <h4 id="team1Name">Team 1</h4>
        <ul id="team1Players" style="text-align: left;"></ul>
      </div>
      <div>
        <h4 id="team2Name">Team 2</h4>
        <ul id="team2Players" style="text-align: left;"></ul>
      </div>
    </div>
  </div>

  <div id="selectionModal" class="selection-modal" style="display: none;">
    <div class="selection-box">
      <h3 id="selectionTitle">Select Next Batter</h3>
      <div id="selectionList" class="selection-list"></div>
      <button id="confirmSelection" style="width: 100%;">Confirm</button>
    </div>
  </div>

  <div id="spectatorEngagement">
    <div id="liveReactions">
      <span title="Fire!">üî•</span>
      <span title="Great play!">üëè</span>
      <span title="Wow!">üò≤</span>
    </div>
    <div id="momentumMeter">
      <div class="meter-bar"></div>
    </div>
  </div>

  <div id="gameControls">
    <button id="saveBtn">üíæ Save & Exit</button>
    <button id="exitBtn">üö™ Exit Without Saving</button>
    <button id="resetPlaysBtn">üîÑ Reset Plays</button>
  </div>
  
  <div id="connectionStatus" class="online">
    Opponent: Online
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
    import { getDatabase, ref, onValue, set, get, update, push } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAGU0Tsj9pwZcgwQjZzTFvGOE032l2b7HI",
      authDomain: "handicricket-d1ab7.firebaseapp.com",
      projectId: "handicricket-d1ab7",
      storageBucket: "handicricket-d1ab7.appspot.com",
      messagingSenderId: "356065986337",
      appId: "1:356065986337:web:399102c5dabfca2b6fe060"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const params = new URLSearchParams(window.location.search);
    const room = params.get('room');
    const player = params.get('player');
    const opponent = player === "player1" ? "player2" : "player1";

    const formatRules = {
      "5": { 
        name: "5 Overs", 
        totalOvers: 5, 
        totalWickets: 11, 
        powerplayOvers: 2, 
        powerplayWicketValue: 0.5,
        regularWicketValue: 1.0,
        livesPerPlayer: 2,
        deadOvers: []
      },
      "10": { 
        name: "10 Overs", 
        totalOvers: 10, 
        totalWickets: 11, 
        powerplayOvers: 3, 
        powerplayWicketValue: 0.5,
        regularWicketValue: 1.0,
        livesPerPlayer: 2,
        deadOvers: []
      },
      "20": { 
        name: "T20", 
        totalOvers: 20, 
        totalWickets: 11, 
        powerplayOvers: 6, 
        powerplayWicketValue: 0.5,
        regularWicketValue: 1.0,
        livesPerPlayer: 2,
        deadOvers: []
      },
      "50": { 
        name: "ODI", 
        totalOvers: 50, 
        totalWickets: 11, 
        powerplayOvers: [1,10, 21,30, 41,42], 
        powerplayWicketValue: 0.25,
        regularWicketValue: 0.5,
        livesPerPlayer: 4,
        deadOvers: [11,20, 31,40]
      },
      "test": { 
        name: "Test Match", 
        totalOvers: Infinity, 
        totalWickets: 30, 
        powerplayOvers: 0, 
        powerplayWicketValue: 0.33,
        regularWicketValue: 0.33,
        livesPerPlayer: 3,
        deadOvers: []
      }
    };

    // Game state variables
    let runs = 0, wickets = 0;
    let legalBalls = 0;
    let freeHit = false;
    let freeHitNextBall = false;
    let currentBatter = null;
    let currentBowler = null;
    let battersUsed = [];
    let bowlersUsed = [];
    let bowlerOvers = {};
    let isBatting = false;
    let currentFormat = {};
    let isTestMatch = false;
    let innings = 1;
    let currentInningRuns = 0;
    let currentInningWickets = 0;
    let team1Score = 0;
    let team2Score = 0;
    let team1Wickets = 0;
    let team2Wickets = 0;
    let daysRemaining = 5;
    let oversToday = 0;
    const maxOversPerDay = 90;
    let isPowerplay = false;
    let isDeadOver = false;
    let batterWickets = {};
    let zerosThisOver = { player1: 0, player2: 0 };
    let currentOver = 0;
    let bowlerRuns = {};
    let gameInProgress = true;
    let lastOverRuns = 0;
    let lastOverWickets = 0;
    let lastWicketScore = 0;
    let ballByBall = {};
    const playerRef = ref(db, `rooms/${room}/${player}/online`);
    const opponentRef = ref(db, `rooms/${room}/${opponent}/online`);
    let playTimeout;
    let batterStats = {};
    let bowlerStats = {};
    let autoStartTimer;
    let countdownInterval;
    let tossWinner = null;
    let battingFirst = null;
    const milestoneLevels = [50, 100, 150, 200, 250, 300, 350, 400];

    // DOM elements
    const status = document.getElementById("status");
    const scoreboard = document.getElementById("scoreboard");
    const buttons = document.querySelectorAll(".card");
    const roleText = document.getElementById("roleText");
    const currentBatterEl = document.getElementById("currentBatter");
    const currentBowlerEl = document.getElementById("currentBowler");
    const selectionModal = document.getElementById("selectionModal");
    const selectionTitle = document.getElementById("selectionTitle");
    const selectionList = document.getElementById("selectionList");
    const confirmSelection = document.getElementById("confirmSelection");
    const team1NameEl = document.getElementById("team1Name");
    const team2NameEl = document.getElementById("team2Name");
    const team1PlayersEl = document.getElementById("team1Players");
    const team2PlayersEl = document.getElementById("team2Players");
    const testControls = document.getElementById("testControls");
    const declareBtn = document.getElementById("declareInning");
    const followOnBtn = document.getElementById("enforceFollowOn");
    const formatDisplay = document.getElementById("formatDisplay");
    const powerplayAlert = document.getElementById("powerplayAlert");
    const freeHitAlert = document.getElementById("freeHitAlert");
    const deadOverAlert = document.getElementById("deadOverAlert");
    const freeHitIndicator = document.getElementById("freeHitIndicator");
    const saveBtn = document.getElementById("saveBtn");
    const exitBtn = document.getElementById("exitBtn");
    const resetPlaysBtn = document.getElementById("resetPlaysBtn");
    const connectionStatus = document.getElementById("connectionStatus");
    const spectatorCountEl = document.getElementById("spectatorCount");
    const targetDisplay = document.getElementById("targetDisplay");
    const targetRunsEl = document.getElementById("targetRuns");
    const requiredRateEl = document.getElementById("requiredRate");
    const miniScoreEl = document.getElementById("miniScore");
    const miniOversEl = document.getElementById("miniOvers");
    const startInningsBtn = document.getElementById("startInningsBtn");
    const opponentReadyStatus = document.getElementById("opponentReadyStatus");
    const autoStartTimerEl = document.getElementById("autoStartTimer");
    const startInningsText = document.getElementById("startInningsText");

    // Initialize batter stats with milestone tracking
    function initializeBatterStats() {
      const roomRef = ref(db, `rooms/${room}`);
      get(roomRef).then(snapshot => {
        const data = snapshot.val();
        
        if (data.player1?.playing11) {
          data.player1.playing11.forEach(player => {
            batterStats[player] = { runs: 0, balls: 0 };
            batterWickets[player] = 0;
            milestoneLevels.forEach(level => {
              batterStats[player][`milestone${level}Notified`] = false;
            });
          });
        }
        
        if (data.player2?.playing11) {
          data.player2.playing11.forEach(player => {
            batterStats[player] = { runs: 0, balls: 0 };
            batterWickets[player] = 0;
            milestoneLevels.forEach(level => {
              batterStats[player][`milestone${level}Notified`] = false;
            });
          });
        }
      });
    }

    // Check for batting milestones (50, 100, 150, etc.)
    function checkBattingMilestones() {
      if (!currentBatter) return;

      const batterRuns = batterStats[currentBatter]?.runs || 0;
      
      for (const milestone of milestoneLevels) {
        if (batterRuns >= milestone && 
            !batterStats[currentBatter][`milestone${milestone}Notified`]) {
          
          const isPlayingXI = (
            document.getElementById('team1Players').textContent.includes(currentBatter) ||
            document.getElementById('team2Players').textContent.includes(currentBatter)
          );
          
          if (isPlayingXI) {
            showNotification(`${currentBatter} scores ${milestone} runs! üéâ`, 'batting');
            batterStats[currentBatter][`milestone${milestone}Notified`] = true;
            
            if (milestone >= 150) {
              createConfetti();
              if (milestone >= 200) {
                playCelebrationSound();
              }
            }
            break;
          }
        }
      }
    }

    // Show notification with different styles
    function showNotification(message, type = 'info') {
      const notif = document.createElement('div');
      notif.className = `milestone-notification ${type}`;
      notif.textContent = message;
      document.body.appendChild(notif);
      setTimeout(() => notif.remove(), 3000);
    }

    // Create confetti effect
    function createConfetti() {
      const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
      for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = `${Math.random() * 100}%`;
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.width = `${Math.random() * 10 + 5}px`;
        confetti.style.height = `${Math.random() * 10 + 5}px`;
        confetti.style.animationDuration = `${Math.random() * 3 + 2}s`;
        document.body.appendChild(confetti);
        setTimeout(() => confetti.remove(), 5000);
      }
    }

    // Play celebration sound (placeholder)
    function playCelebrationSound() {
      console.log("Playing celebration sound!");
    }

    // Function to start the second innings
    async function startSecondInnings() {
      try {
        disableButtons();
        status.innerText = "Starting second innings...";
        
        if (countdownInterval) clearInterval(countdownInterval);
        
        await set(ref(db, `rooms/${room}/startSecondInnings`), true);
        
        const overlay = showTransitionOverlay("Starting Second Innings...", 3);
        
        await update(ref(db, `rooms/${room}`), {
          currentPlays: { player1: null, player2: null },
          currentBatter: null,
          currentBowler: null,
          inningsReady: null,
          autoStartTime: null
        });
        
        setTimeout(() => {
          innings++;
          startInningsBtn.style.display = "none";
          resetInning();
          overlay.remove();
        }, 3000);
      } catch (error) {
        console.error("Error starting second innings:", error);
        status.innerText = "Error starting second innings. Please try again.";
        enableButtons();
      }
    }

    // Update spectator data with match details
    function updateSpectatorData() {
      const currentOver = Math.floor(legalBalls / 6);
      if (currentOver > lastOverRuns) {
        const overSummary = `Over ${currentOver}: ${runs - lastOverRuns} runs, ${wickets - lastOverWickets} wickets`;
        set(ref(db, `rooms/${room}/overSummaries/${currentOver}`), overSummary);
        lastOverRuns = runs;
        lastOverWickets = wickets;
      }

      const runRate = legalBalls > 0 ? (runs / (legalBalls / 6)).toFixed(2) : "0.00";
      const boundaries = Object.values(ballByBall).filter(ball => [4,6].includes(ball.runs)).length;
      const requiredRate = innings === 2 ? ((team1Score - runs + 1) / Math.max(1, (currentFormat.totalOvers * 6 - legalBalls) / 6)).toFixed(2) : null;

      set(ref(db, `rooms/${room}/matchStats`), {
        runRate: runRate,
        boundaries: boundaries,
        dotBalls: Object.values(ballByBall).filter(ball => ball.runs === 0).length,
        wickets: Math.floor(wickets),
        partnership: runs - lastWicketScore,
        requiredRate: requiredRate,
        currentOver: `${currentOver}.${legalBalls % 6}`,
        isPowerplay: isPowerplay,
        isDeadOver: isDeadOver,
        freeHit: freeHit
      });

      set(ref(db, `rooms/${room}/liveState`), {
        runs: runs,
        wickets: Math.floor(wickets),
        legalBalls: legalBalls,
        currentBatter: currentBatter,
        currentBowler: currentBowler,
        isPowerplay: isPowerplay,
        isDeadOver: isDeadOver,
        freeHit: freeHit,
        innings: innings,
        timestamp: Date.now()
      });
    }

    // Update free hit display
    function updateFreeHitDisplay() {
      freeHitIndicator.style.display = freeHit ? "inline-block" : "none";
      freeHitAlert.style.display = freeHit ? "block" : "none";
    }

    // Update target display for 2nd innings
    function updateTargetDisplay() {
      if (innings === 2) {
        targetDisplay.style.display = "block";
        targetRunsEl.textContent = team1Score + 1;
        
        const ballsRemaining = currentFormat.totalOvers * 6 - legalBalls;
        if (ballsRemaining > 0) {
          const requiredRuns = team1Score - runs + 1;
          const requiredRate = (requiredRuns / (ballsRemaining / 6)).toFixed(2);
          requiredRateEl.textContent = `RR: ${requiredRate}`;
        } else {
          requiredRateEl.textContent = "";
        }
      } else {
        targetDisplay.style.display = "none";
      }
    }

    // Update mini scorecard
    function updateMiniScorecard() {
      miniScoreEl.textContent = `${runs}/${Math.floor(wickets)}`;
      miniOversEl.textContent = `${Math.floor(legalBalls/6)}.${legalBalls%6}`;
    }

    // Update momentum meter
    function updateMomentum() {
      const boundaryCount = Object.values(ballByBall)
        .filter(ball => ball.runs >= 4).length;
      const meter = document.querySelector('.meter-bar');
      const momentum = Math.min(100, boundaryCount * 5);
      meter.style.width = `${momentum}%`;
      meter.style.backgroundColor = momentum > 70 ? '#4CAF50' : 
                                  momentum > 30 ? '#FFC107' : '#F44336';
    }

    // Check for milestones (centuries, 5-wicket hauls)
    function checkMilestones() {
      if (currentBatter && batterStats[currentBatter]?.runs >= 100 && 
          !batterStats[currentBatter].centuryNotified) {
        showNotification(`${currentBatter} scores a century! üéâ`, 'batting');
        batterStats[currentBatter].centuryNotified = true;
        createConfetti();
        playCelebrationSound();
      }
      if (currentBowler && bowlerStats[currentBowler]?.wickets >= 5 && 
          !bowlerStats[currentBowler].fiveWicketNotified) {
        showNotification(`${currentBowler} takes 5 wickets! üéØ`, 'bowling');
        bowlerStats[currentBowler].fiveWicketNotified = true;
        createConfetti();
      }
    }

    // Show transition overlay with countdown
    function showTransitionOverlay(message, duration = 5) {
      const overlay = document.createElement('div');
      overlay.className = 'transition-overlay';
      
      const messageEl = document.createElement('div');
      messageEl.className = 'transition-message';
      messageEl.textContent = message;
      
      const countdownEl = document.createElement('div');
      countdownEl.className = 'transition-countdown';
      countdownEl.textContent = duration;
      
      overlay.appendChild(messageEl);
      overlay.appendChild(countdownEl);
      document.body.appendChild(overlay);
      
      let count = duration;
      const countdown = setInterval(() => {
        count--;
        countdownEl.textContent = count;
        if (count <= 0) {
          clearInterval(countdown);
          overlay.remove();
        }
      }, 1000);
      
      return overlay;
    }

    // Load playing 11 from Firebase
    async function loadPlaying11() {
      const roomRef = ref(db, `rooms/${room}`);
      const snapshot = await get(roomRef);
      const data = snapshot.val();

      if (!data) {
        alert("Room data not found! Returning to home.");
        window.location.href = "index.html";
        return false;
      }

      if (data.player1?.playing11) {
        team1NameEl.innerText = data.player1.teamName || "Team 1";
        team1PlayersEl.innerHTML = data.player1.playing11.map(p => `<li>${p}</li>`).join("");
      }
      
      if (data.player2?.playing11) {
        team2NameEl.innerText = data.player2.teamName || "Team 2";
        team2PlayersEl.innerHTML = data.player2.playing11.map(p => `<li>${p}</li>`).join("");
      }

      return data.player1?.playing11 && data.player2?.playing11;
    }

    // Monitor connection status
    function setupConnectionMonitoring() {
      set(playerRef, { status: true, timestamp: Date.now() });
      
      const connectionTimeout = 15000;
      
      onValue(opponentRef, (snap) => {
        if (!snap.exists() || !snap.val()) {
          connectionStatus.textContent = "Opponent: Offline (Game Paused)";
          connectionStatus.className = "offline";
          disableButtons();
        } else {
          const lastSeen = snap.val().timestamp || 0;
          const timeDiff = Date.now() - lastSeen;
          
          if (timeDiff > connectionTimeout) {
            connectionStatus.textContent = "Opponent: Lagging (Slow Connection)";
            connectionStatus.className = "offline";
            disableButtons();
          } else {
            connectionStatus.textContent = "Opponent: Online";
            connectionStatus.className = "online";
            if (!selectionModal.style.display || selectionModal.style.display === "none") {
              enableButtons();
            }
          }
        }
      });
      
      setInterval(() => {
        set(playerRef, { status: true, timestamp: Date.now() });
      }, 5000);
      
      window.addEventListener('beforeunload', () => {
        set(playerRef, { status: false, timestamp: Date.now() });
      });
    }

    // Handle back button
    function setupBackButtonHandling() {
      window.addEventListener('beforeunload', (e) => {
        if (gameInProgress) {
          e.preventDefault();
          e.returnValue = 'Are you sure you want to leave?';
          return e.returnValue;
        }
      });
      
      if (window.history && window.history.pushState) {
        window.history.pushState('forward', null, './');
        window.onpopstate = function() {
          if (confirm("Exit game? Your progress will be lost unless saved.")) {
            resetGame();
            window.location.href = "index.html";
          } else {
            window.history.pushState('forward', null, './');
          }
        };
      }
    }

    // Save game state
    async function saveGameState() {
      const gameState = {
        timestamp: Date.now(),
        players: {
          player1: { 
            team: document.getElementById('team1Name').textContent,
            score: team1Score 
          },
          player2: { 
            team: document.getElementById('team2Name').textContent,
            score: team2Score 
          }
        },
        innings: innings,
        currentBatter: currentBatter,
        currentBowler: currentBowler,
        ballsRemaining: currentFormat.totalOvers * 6 - legalBalls,
        batterWickets: batterWickets,
        bowlerOvers: bowlerOvers,
        runs: runs,
        wickets: wickets,
        currentInningRuns: currentInningRuns,
        currentInningWickets: currentInningWickets,
        batterStats: batterStats,
        bowlerStats: bowlerStats
      };
      
      await set(ref(db, `savedGames/${room}`), gameState);
      await set(playerRef, false);
      alert("Game saved! You can resume from the home screen.");
      window.location.href = "index.html";
    }

    // Reset game state
    async function resetGame() {
      await update(ref(db, `rooms/${room}`), {
        currentPlays: null,
        currentBatter: null,
        currentBowler: null,
        inningsReady: null,
        startSecondInnings: null,
        autoStartTime: null
      });
      await set(playerRef, false);
    }

    // Disable all card buttons
    function disableButtons() {
      buttons.forEach(btn => btn.disabled = true);
      if (startInningsBtn.style.display !== "none") {
        startInningsBtn.disabled = true;
      }
    }

    // Enable all card buttons
    function enableButtons() {
      buttons.forEach(btn => btn.disabled = false);
      if (startInningsBtn.style.display !== "none") {
        startInningsBtn.disabled = false;
      }
    }

    // Check powerplay status based on current over
    function checkPowerplayStatus() {
      const currentOver = Math.floor(legalBalls / 6);
      
      isPowerplay = false;
      isDeadOver = false;
      
      powerplayAlert.style.display = "none";
      deadOverAlert.style.display = "none";

      if (isTestMatch) return;

      if (Array.isArray(currentFormat.powerplayOvers)) {
        for (let i = 0; i < currentFormat.powerplayOvers.length; i += 2) {
          const startOver = currentFormat.powerplayOvers[i] - 1;
          const endOver = currentFormat.powerplayOvers[i+1] - 1;
          
          if (currentOver >= startOver && currentOver <= endOver) {
            isPowerplay = true;
            powerplayAlert.style.display = "block";
            break;
          }
        }
      } else if (currentOver < currentFormat.powerplayOvers) {
        isPowerplay = true;
        powerplayAlert.style.display = "block";
      }

      if (Array.isArray(currentFormat.deadOvers) && currentFormat.deadOvers.length > 0) {
        for (let i = 0; i < currentFormat.deadOvers.length; i += 2) {
          const startOver = currentFormat.deadOvers[i] - 1;
          const endOver = currentFormat.deadOvers[i+1] - 1;
          
          if (currentOver >= startOver && currentOver <= endOver) {
            isDeadOver = true;
            deadOverAlert.style.display = "block";
            break;
          }
        }
      }

      updateFreeHitDisplay();
    }

    // Update scoreboard display
    function updateScoreboard() {
      const overs = Math.floor(legalBalls / 6);
      const balls = legalBalls % 6;
      const displayWickets = Math.floor(wickets);
      const totalWickets = currentFormat.totalWickets;
      const isLimitedOvers = !isTestMatch;

      let scoreHTML = `
          <div>Runs: <strong>${runs}</strong></div>
          <div>Wickets: <strong>${displayWickets}/${totalWickets}</strong></div>
          <div>Overs: <strong>${overs}.${balls}</strong></div>
      `;

      if (isTestMatch) {
          const currentDay = 6 - daysRemaining;
          scoreHTML = `
              <div><strong>Innings ${innings}</strong> | Day ${currentDay}</div>
              <div>Current: ${currentInningRuns}/${displayWickets} (${overs}.${balls})</div>
              <div>Team 1: ${team1Score}/${Math.floor(team1Wickets)}</div>
              <div>Team 2: ${team2Score}/${Math.floor(team2Wickets)}</div>
              <div>Overs today: ${oversToday}/${maxOversPerDay}</div>
          `;
      } else {
          const remainingBalls = (currentFormat.totalOvers * 6) - legalBalls;
          const remainingOvers = Math.floor(remainingBalls / 6) + (remainingBalls % 6) / 10;
          
          scoreHTML += `
              <div>Remaining: ${remainingOvers.toFixed(1)} overs</div>
              <div>Run Rate: ${(runs / (legalBalls / 6)).toFixed(2)}</div>
          `;

          if (currentFormat.powerplayOvers > 0) {
              const powerplayDone = overs >= currentFormat.powerplayOvers;
              scoreHTML += `<div>Powerplay: ${powerplayDone ? 'Completed' : `${currentFormat.powerplayOvers - overs} overs left`}</div>`;
          }

          if (innings === 2) {
              const target = team1Score + 1;
              const needed = target - runs;
              scoreHTML += `
                  <div>Target: <strong>${target}</strong></div>
                  <div>Need: <strong>${needed} runs</strong> in ${remainingBalls} balls</div>
                  <div>Req. Rate: <strong>${(needed / (remainingBalls / 6)).toFixed(2)}</strong></div>
              `;
          }
      }

      if (isPowerplay) {
          scoreHTML += '<div class="powerplay-indicator">POWERPLAY</div>';
      }
      if (isDeadOver) {
          scoreHTML += '<div class="dead-over">DEAD OVER</div>';
      }
      if (freeHit) {
          scoreHTML += '<div class="free-hit-indicator">FREE HIT</div>';
      }

      scoreboard.innerHTML = scoreHTML;
      updateMiniScorecard();
      checkPowerplayStatus();
      updateMomentum();
      checkMilestones();
      checkBattingMilestones();
    }

    // Reset plays after each ball
    async function resetPlays() {
      try {
        await update(ref(db, `rooms/${room}`), {
          'currentPlays/player1': null,
          'currentPlays/player2': null
        });
        enableButtons();
      } catch (error) {
        console.error("Error resetting plays:", error);
        enableButtons();
      }
    }

    // Set up player roles (batting/bowling)
    async function setupRole() {
      const tossSnap = await get(ref(db, `rooms/${room}/tossWinner`));
      tossWinner = tossSnap.val();
      
      const battingFirstSnap = await get(ref(db, `rooms/${room}/battingFirst`));
      battingFirst = battingFirstSnap.val();
      
      isBatting = (innings % 2 === 1) ? (player === battingFirst) : (player !== battingFirst);

      const decisionSnap = await get(ref(db, `rooms/${room}/decision`));
      const decision = decisionSnap.val();
      const teamSnap = await get(ref(db, `rooms/${room}/${opponent}/playing11`));
      const opponentTeam = teamSnap.val()?.[0] || "Opponent";

      roleText.innerText = isBatting ? 
        `You are Batting (${decision === 'bat' ? 'chose to bat' : 'chose to bowl'}) vs ${opponentTeam}` : 
        `You are Bowling (${decision === 'bowl' ? 'chose to bowl' : 'chose to bat'}) vs ${opponentTeam}`;

      currentBatterEl.innerText = "-";
      currentBowlerEl.innerText = "-";

      if (isBatting && !currentBatter) {
        showBatterSelection();
      }
      
      if (!isBatting && !currentBowler) {
        showBowlerSelection();
      }
    }

    // Set up selection modal for batters/bowlers
    function setupSelectionModal() {
      confirmSelection.addEventListener("click", async () => {
        const selectedPlayer = document.querySelector(".batter-item.selected") || document.querySelector(".player-item.selected");
        if (!selectedPlayer) return;

        const playerName = selectedPlayer.dataset.name;
        const selectionType = selectionTitle.textContent.includes("Batter") ? "batter" : "bowler";

        if (selectionType === "batter") {
          currentBatter = playerName;
          battersUsed.push(playerName);
          batterWickets[playerName] = 0;
          currentBatterEl.innerText = playerName;
          await set(ref(db, `rooms/${room}/currentBatter`), playerName);
        } else {
          currentBowler = playerName;
          bowlerOvers[playerName] = bowlerOvers[playerName] || 0;
          currentBowlerEl.innerText = playerName;
          await set(ref(db, `rooms/${room}/currentBowler`), playerName);
        }

        selectionModal.style.display = "none";
        enableButtons();
        status.innerText = "Play your card...";
      });
    }

    // Enhanced batter selection modal
    async function showBatterSelection() {
      disableButtons();
      try {
        const snapshot = await get(ref(db, `rooms/${room}/${player}/playing11`));
        const players = snapshot.val();
        
        const availableBatters = players.filter(p => 
          !battersUsed.includes(p) || 
          (batterWickets[p] !== undefined && batterWickets[p] < 1.0)
        );
        
        if (availableBatters.length === 0) {
          showStatus("All batters are out!", 'alert');
          return;
        }

        selectionTitle.textContent = "Select Next Batter";
        selectionList.innerHTML = "";
        
        availableBatters.forEach(player => {
          const stats = batterStats[player] || { runs: 0, balls: 0 };
          const wicketsLost = batterWickets[player] || 0;
          const strikeRate = stats.balls > 0 ? (stats.runs / stats.balls * 100).toFixed(2) : "0.00";
          const wicketsLeft = (1.0 - wicketsLost).toFixed(2);
          
          const batterEl = document.createElement("div");
          batterEl.className = "batter-item";
          batterEl.innerHTML = `
            <div>${player}</div>
            <div class="batter-stats">
              <div class="batter-status">
                <span class="batter-runs">${stats.runs} runs</span>
                <span class="batter-balls">${stats.balls} balls</span>
                <span class="batter-sr">SR: ${strikeRate}</span>
              </div>
              <div class="wickets-left">${wicketsLeft}/1.0 wickets left</div>
            </div>
          `;
          batterEl.dataset.name = player;
          batterEl.addEventListener("click", function() {
            document.querySelectorAll(".batter-item").forEach(el => el.classList.remove("selected"));
            this.classList.add("selected");
          });
          selectionList.appendChild(batterEl);
        });

        selectionModal.style.display = "flex";
        showStatus("Select your next batter...");
        
      } catch (error) {
        console.error("Batter selection error:", error);
        showStatus("Error loading batters", 'alert');
        enableButtons();
      }
    }

    // Show bowler selection modal
    async function showBowlerSelection() {
      disableButtons();
      try {
        const snapshot = await get(ref(db, `rooms/${room}/${player}/playing11`));
        const players = snapshot.val();
        const maxOversPerBowler = isTestMatch ? Infinity : Math.ceil(currentFormat.totalOvers / 5);
        const availableBowlers = players.filter(p => (bowlerOvers[p] || 0) < maxOversPerBowler);
        
        if (availableBowlers.length === 0) {
          alert("All bowlers have bowled their maximum overs!");
          return;
        }

        selectionTitle.textContent = "Select Next Bowler";
        selectionList.innerHTML = "";
        
        availableBowlers.forEach(player => {
          const oversBowled = bowlerOvers[player] || 0;
          const wicketsTaken = bowlerStats[player]?.wickets || 0;
          const runsConceded = bowlerStats[player]?.runs || 0;
          
          const playerEl = document.createElement("div");
          playerEl.className = "player-item";
          playerEl.innerHTML = `
            <div>${player}</div>
            <div class="bowler-stats">
              ${oversBowled.toFixed(1)} overs | 
              ${wicketsTaken} wickets | 
              ${runsConceded} runs
            </div>
          `;
          playerEl.dataset.name = player;
          playerEl.addEventListener("click", function() {
            document.querySelectorAll(".player-item").forEach(el => el.classList.remove("selected"));
            this.classList.add("selected");
          });
          selectionList.appendChild(playerEl);
        });

        selectionModal.style.display = "flex";
        status.innerText = "Selecting bowler...";
      } catch (error) {
        console.error("Bowler selection error:", error);
        alert("Error loading bowlers. Please try again.");
        enableButtons();
      }
    }

    // Set up test match controls
    function setupTestControls() {
      declareBtn.addEventListener("click", async () => {
        if (confirm("Are you sure you want to declare this innings?")) {
          disableButtons();
          status.innerText = "Innings declared!";
          
          if (innings === 1) {
            team1Score = currentInningRuns;
            team1Wickets = wickets;
          } else {
            team2Score = currentInningRuns;
            team2Wickets = wickets;
          }
          
          await set(ref(db, `rooms/${room}/declared`), true);
          endInning();
        }
      });

      followOnBtn.addEventListener("click", async () => {
        if (confirm("Enforce follow-on and make Team 2 bat again?")) {
          disableButtons();
          status.innerText = "Follow-on enforced!";
          
          innings = 2;
          await set(ref(db, `rooms/${room}/followOn`), false);
          resetInning();
          
          followOnBtn.style.display = "none";
        }
      });
    }

    // Set up the innings button with enhanced functionality
    function setupInningsButton() {
      startInningsBtn.addEventListener("click", startSecondInnings);

      onValue(ref(db, `rooms/${room}/inningsReady`), (snap) => {
        if (!snap.exists()) return;
        
        const isReady = snap.val();
        
        if (isReady && innings === 1 && !isTestMatch) {
          if (!startInningsBtn.disabled) {
            opponentReadyStatus.style.display = "flex";
            startInningsText.textContent = "Ready to Start";
            startInningsBtn.disabled = false;
            
            status.innerText = `Team 1 scored ${team1Score} runs! Opponent is ready to start second innings.`;
          }
        }
      });

      onValue(ref(db, `rooms/${room}/autoStartTime`), (snap) => {
        if (!snap.exists() || !snap.val()) return;
        
        const startTime = snap.val();
        const now = Date.now();
        
        if (startTime > now) {
          autoStartTimerEl.style.display = "block";
          
          if (countdownInterval) clearInterval(countdownInterval);
          countdownInterval = setInterval(() => {
            const remaining = Math.max(0, Math.ceil((startTime - Date.now()) / 1000));
            autoStartTimerEl.textContent = `Auto-start in ${remaining}s`;
            
            if (remaining <= 0) {
              clearInterval(countdownInterval);
              autoStartTimerEl.style.display = "none";
            }
          }, 1000);
        }
      });

      onValue(ref(db, `rooms/${room}/startSecondInnings`), (snap) => {
        if (snap.exists() && snap.val() && innings === 1 && !isTestMatch) {
          const overlay = showTransitionOverlay("Second Innings Starting!", 3);
          
          setTimeout(() => {
            innings++;
            startInningsBtn.style.display = "none";
            resetInning();
            overlay.remove();
          }, 3000);
        }
      });
    }

    // Set up Firebase listeners
    function setupFirebaseListeners() {
      if (playTimeout) {
        clearTimeout(playTimeout);
      }

      playTimeout = setTimeout(async () => {
        if (status.textContent.includes("Waiting for opponent")) {
          console.log("Timeout reached, resetting plays");
          await resetPlays();
          status.innerText = "Timeout - Resetting plays...";
        }
      }, 10000);

      onValue(ref(db, `rooms/${room}`), (snap) => {
        const data = snap.val();
        if (!data) return;

        if (data.player1?.playing11) {
          team1NameEl.innerText = data.player1.teamName || "Team 1";
          team1PlayersEl.innerHTML = data.player1.playing11.map(p => `<li>${p}</li>`).join("");
        }
        
        if (data.player2?.playing11) {
          team2NameEl.innerText = data.player2.teamName || "Team 2";
          team2PlayersEl.innerHTML = data.player2.playing11.map(p => `<li>${p}</li>`).join("");
        }
      });

      onValue(ref(db, `rooms/${room}/currentPlays`), async (snap) => {
        const plays = snap.val();
        
        if (!plays || plays.player1 === undefined || plays.player2 === undefined) {
          return;
        }

        if (plays.player1 === null || plays.player2 === null) {
          return;
        }

        const connectionSnap = await get(ref(db, `rooms/${room}/${opponent}/online`));
        if (!connectionSnap.exists() || !connectionSnap.val()) {
          status.innerText = "Opponent disconnected. Waiting...";
          return;
        }

        const battingPlayer = innings % 2 === 1 ? battingFirst : (battingFirst === "player1" ? "player2" : "player1");
        const bowlingPlayer = battingPlayer === "player1" ? "player2" : "player1";

        const batCard = plays[battingPlayer];
        const bowlCard = plays[bowlingPlayer];

        let outcome = "";
        let isLegalBall = false;
        let isWicket = false;
        let isPlayerOut = false;
        let runsScored = 0;

        if (batCard === 0) zerosThisOver[battingPlayer]++;
        if (bowlCard === 0) zerosThisOver[bowlingPlayer]++;

        if (freeHitNextBall) {
          freeHit = true;
          freeHitNextBall = false;
          updateFreeHitDisplay();
        }

        if (batCard === 0 && bowlCard === 0) {
          if (!isTestMatch) {
            outcome = "NO BALL! +1 run (Free Hit next ball)";
            runs += 1;
            currentInningRuns += 1;
            freeHitNextBall = true;
            isLegalBall = false;
          } else {
            outcome = "No run (Test Match)";
          }
        } 
        else if (freeHit) {
          if (batCard === bowlCard && batCard > 0) {
            outcome = "Wicket on Free Hit (not out)";
            isWicket = false;
          } else {
            runsScored = batCard;
            runs += batCard;
            currentInningRuns += batCard;
            outcome = `${batCard} Run(s)! (Free Hit)`;
          }
          freeHit = false;
          updateFreeHitDisplay();
          isLegalBall = true;
        }
        else if (batCard === bowlCard && batCard > 0) {
          let wicketValue;
          if (isTestMatch) {
            wicketValue = 0.33;
          } 
          else if (currentFormat.name === "ODI") {
            wicketValue = isPowerplay ? 0.25 : 0.5;
          }
          else {
            wicketValue = isPowerplay ? 0.5 : 1.0;
          }
          
          if (!batterWickets[currentBatter]) {
            batterWickets[currentBatter] = 0;
          }
          
          batterWickets[currentBatter] += wicketValue;
          wickets += wicketValue;
          
          if (batterWickets[currentBatter] >= 1.0) {
            isPlayerOut = true;
            outcome = "WICKET! (Out)";
            wickets = Math.ceil(wickets);
            batterWickets[currentBatter] = 0;
          } else {
            outcome = `WICKET! (${(1.0 - batterWickets[currentBatter]).toFixed(2)} wickets left)`;
          }
          
          isLegalBall = true;
          isWicket = true;
        }
        else if (batCard === 0 && bowlCard > 0) {
          if (zerosThisOver[battingPlayer] > 3) {
            runs -= 5;
            outcome = "4th 0 in over! -5 runs";
          } else {
            if (isTestMatch) {
              bowlerRuns[currentBowler] = (bowlerRuns[currentBowler] || 0) + bowlCard;
              outcome = `Bowler's ${bowlCard} runs added to their stats`;
            } else {
              runsScored = bowlCard;
              runs += bowlCard;
              currentInningRuns += bowlCard;
              outcome = `Batter played 0. Runs = ${bowlCard}`;
            }
          }
          isLegalBall = true;
        }
        else if (bowlCard === 0 && batCard > 0) {
          if (zerosThisOver[bowlingPlayer] > 3 && !isTestMatch) {
            outcome = "4th 0 in over! No ball";
            runs += 1;
            freeHitNextBall = true;
          } else {
            if (isTestMatch) {
              runsScored = batCard;
              runs += batCard;
              currentInningRuns += batCard;
              outcome = `${batCard} Run(s)!`;
            } else {
              outcome = "DOT BALL!";
            }
          }
          isLegalBall = true;
        }
        else {
          runsScored = batCard;
          runs += batCard;
          currentInningRuns += batCard;
          outcome = `${batCard} Run(s)!`;
          isLegalBall = true;
        }

        if (currentBatter && runsScored > 0) {
          batterStats[currentBatter] = batterStats[currentBatter] || { runs: 0, balls: 0 };
          batterStats[currentBatter].runs += runsScored;
          batterStats[currentBatter].balls += 1;
        }
        
        if (currentBowler && isWicket) {
          bowlerStats[currentBowler] = bowlerStats[currentBowler] || { wickets: 0, runs: 0, overs: 0 };
          bowlerStats[currentBowler].wickets += 1;
        }

        ballByBall[legalBalls] = {
          runs: batCard,
          wicket: isWicket || isPlayerOut,
          batter: currentBatter,
          bowler: currentBowler,
          timestamp: Date.now()
        };

        if (isWicket) {
          lastWicketScore = runs;
        }

        if (isLegalBall) {
          legalBalls++;
          if (isTestMatch) oversToday++;
          
          if (currentBowler) {
            bowlerOvers[currentBowler] = (bowlerOvers[currentBowler] || 0) + (1/6);
            if (legalBalls % 6 === 0) {
              bowlerOvers[currentBowler] = Math.round(bowlerOvers[currentBowler] * 10) / 10;
              zerosThisOver = { player1: 0, player2: 0 };
            }
          }
          
          if (isTestMatch && oversToday >= maxOversPerDay) {
            endDaysPlay();
            return;
          }
        }

        status.innerText = outcome;
        updateScoreboard();
        updateSpectatorData();
        
        if (innings === 2 && runs > team1Score) {
          endMatch();
          return;
        }
        
        if ((isTestMatch && currentInningWickets >= 30) || 
            (!isTestMatch && (wickets >= currentFormat.totalWickets || legalBalls >= currentFormat.totalOvers * 6))) {
          endInning();
          return;
        }

        setTimeout(async () => {
          await resetPlays();
          
          if ((isPlayerOut || isWicket) && player === battingPlayer) {
            showBatterSelection();
          } else if (isLegalBall && legalBalls % 6 === 0) {
            if (player === bowlingPlayer) {
              showBowlerSelection();
            } else {
              status.innerText = "Waiting for opponent to select bowler...";
            }
          } else {
            status.innerText = freeHit ? "FREE HIT! Play your next card." : "Play your next card.";
            enableButtons();
          }
        }, 1500);
      });

      onValue(ref(db, `rooms/${room}/currentBatter`), (snap) => {
        const batter = snap.val();
        if (batter && batter !== currentBatter) {
          currentBatter = batter;
          currentBatterEl.innerText = batter;
          if (!battersUsed.includes(batter)) {
            battersUsed.push(batter);
            if (batterWickets[batter] === undefined) {
              batterWickets[batter] = 0;
            }
          }
        }
      });

      onValue(ref(db, `rooms/${room}/currentBowler`), (snap) => {
        const bowler = snap.val();
        if (bowler && bowler !== currentBowler) {
          currentBowler = bowler;
          currentBowlerEl.innerText = bowler;
        }
      });

      onValue(ref(db, `rooms/${room}/followOn`), (snap) => {
        const followOn = snap.val();
        followOnBtn.style.display = followOn ? "block" : "none";
      });

      onValue(ref(db, `rooms/${room}/spectators`), (snap) => {
        const spectators = snap.val() || {};
        spectatorCountEl.textContent = `Spectators: ${Object.keys(spectators).length}`;
      });

      onValue(ref(db, `rooms/${room}/reactions`), (snap) => {
        const reactions = snap.val();
        if (!reactions) return;
        const lastReaction = Object.values(reactions).pop();
        if (lastReaction.player !== player) {
          const reactionEl = document.createElement('div');
          reactionEl.textContent = lastReaction.emoji;
          reactionEl.style.position = 'fixed';
          reactionEl.style.fontSize = '48px';
          reactionEl.style.animation = 'fadeInOut 2s';
          reactionEl.style.zIndex = '999';
          reactionEl.style.left = `${Math.random() * 70 + 15}%`;
          reactionEl.style.top = `${Math.random() * 70 + 15}%`;
          document.body.appendChild(reactionEl);
          setTimeout(() => reactionEl.remove(), 2000);
        }
      });
    }

    // Set up card button events
    buttons.forEach(btn => {
      btn.addEventListener("click", async () => {
        const val = parseInt(btn.dataset.value);
        disableButtons();
        status.innerText = "Waiting for opponent...";
        
        try {
          const opponentOnline = await get(ref(db, `rooms/${room}/${opponent}/online`));
          if (!opponentOnline.exists() || !opponentOnline.val()) {
            status.innerText = "Opponent is offline!";
            enableButtons();
            return;
          }
          
          await update(ref(db, `rooms/${room}`), {
            [`currentPlays/${player}`]: val,
            [`lastPlayTime/${player}`]: Date.now()
          });
        } catch (error) {
          console.error("Error submitting play:", error);
          status.innerText = "Error submitting play - try again";
          enableButtons();
        }
      });
    });

    // End current inning
    async function endInning() {
      disableButtons();
      
      if (innings === 1) {
        team1Score = currentInningRuns;
        team1Wickets = wickets;
        status.innerText = `Team 1 scored ${team1Score} runs!`;
        
        if (!isTestMatch) {
          startInningsBtn.style.display = "block";
          status.innerText += " Click 'Start Second Innings' when ready.";
          
          await set(ref(db, `rooms/${room}/inningsReady`), false);
          
          const autoStartTime = Date.now() + 30000;
          await set(ref(db, `rooms/${room}/autoStartTime`), autoStartTime);
          
          return;
        }
      } else {
        team2Score = currentInningRuns;
        team2Wickets = wickets;
        status.innerText = `Team 2 scored ${team2Score} runs!`;
      }
      
      const followOnPossible = isTestMatch && innings === 2 && team1Score - team2Score >= 200;
      
      if (followOnPossible) {
        status.innerText = `Team 1 can enforce follow-on (lead of ${team1Score - team2Score})`;
        followOnBtn.style.display = "block";
        await set(ref(db, `rooms/${room}/followOn`), true);
      } else {
        if (isTestMatch) {
          innings++;
          if (innings > 2) {
            endMatch();
            return;
          }
          resetInning();
        }
      }
      
      updateScoreboard();
      updateSpectatorData();
    }

    // Reset inning state
    function resetInning() {
      runs = 0;
      wickets = 0;
      currentInningRuns = 0;
      currentInningWickets = 0;
      legalBalls = 0;
      oversToday = 0;
      battersUsed = [];
      bowlerOvers = {};
      batterWickets = {};
      freeHit = false;
      freeHitNextBall = false;
      currentBatter = null;
      currentBowler = null;
      zerosThisOver = { player1: 0, player2: 0 };
      
      set(ref(db, `rooms/${room}/currentPlays`), { player1: null, player2: null });
      
      isBatting = (innings % 2 === 1) ? (player === battingFirst) : (player !== battingFirst);
      
      startInningsBtn.style.display = "none";
      opponentReadyStatus.style.display = "none";
      autoStartTimerEl.style.display = "none";
      startInningsText.textContent = "Start Second Innings";
      
      set(ref(db, `rooms/${room}/inningsReady`), false);
      set(ref(db, `rooms/${room}/autoStartTime`), null);
      set(ref(db, `rooms/${room}/currentBatter`), null);
      set(ref(db, `rooms/${room}/currentBowler`), null);
      
      setupRole();
      
      if (isBatting) {
        showBatterSelection();
      } else {
        showBowlerSelection();
      }
    }

    // End day's play (Test matches)
    function endDaysPlay() {
      disableButtons();
      status.innerText = "Stumps for the day!";
      daysRemaining--;
      
      setTimeout(() => {
        if (daysRemaining > 0) {
          oversToday = 0;
          enableButtons();
          status.innerText = `Day ${6 - daysRemaining} starting...`;
          updateScoreboard();
          updateSpectatorData();
        } else {
          endMatch();
        }
      }, 3000);
    }

    // End match and show result
    function endMatch() {
      let result = "";
      let winner = "";
      let winMargin = 0;
      
      if (isTestMatch) {
        if (team1Score > team2Score) {
          winMargin = team1Score - team2Score;
          result = `Team 1 wins by ${winMargin} runs`;
          winner = "player1";
        } else if (team2Score > team1Score) {
          winMargin = 10 - Math.floor(team2Wickets);
          result = `Team 2 wins by ${winMargin} wickets`;
          winner = "player2";
        } else {
          result = "Match drawn";
        }
      } else {
        if (innings === 2) {
          if (team2Score > team1Score) {
            winMargin = currentFormat.totalWickets - Math.floor(team2Wickets);
            result = `Team 2 wins by ${winMargin} wickets`;
            winner = "player2";
          } else if (team1Score > team2Score) {
            winMargin = team1Score - team2Score;
            result = `Team 1 wins by ${winMargin} runs`;
            winner = "player1";
          } else {
            result = "Match tied";
          }
        } else {
          winMargin = currentFormat.totalWickets - Math.floor(team1Wickets);
          result = `Team 1 wins by ${winMargin} wickets`;
          winner = "player1";
        }
      }
      
      if (winner) {
        const winnerName = winner === "player1" ? 
          document.getElementById('team1Name').textContent : 
          document.getElementById('team2Name').textContent;
          
        showNotification(`${winnerName} wins the match! üèÜ`, 'winner');
        createConfetti();
        playCelebrationSound();
        
        if (winner === "player1") {
          document.getElementById('team1Name').classList.add('team-winner');
          document.getElementById('team1Players').classList.add('team-winner');
        } else {
          document.getElementById('team2Name').classList.add('team-winner');
          document.getElementById('team2Players').classList.add('team-winner');
        }
      }
      
      status.innerText = `Match Over! ${result}`;
      disableButtons();
      set(ref(db, `rooms/${room}/result`), result);
      updateSpectatorData();
      
      setTimeout(() => {
        window.location.href = `result.html?room=${room}&player=${player}&winner=${winner}&result=${encodeURIComponent(result)}`;
      }, 5000);
    }

    // Initialize the game
    async function initGame() {
      gameInProgress = true;
      
      const tossSnap = await get(ref(db, `rooms/${room}/tossWinner`));
      tossWinner = tossSnap.val();
      
      const battingFirstSnap = await get(ref(db, `rooms/${room}/battingFirst`));
      battingFirst = battingFirstSnap.val();
      
      const savedGameSnap = await get(ref(db, `savedGames/${room}`));
      if (savedGameSnap.exists()) {
        const savedData = savedGameSnap.val();
        if (confirm("Resume saved game?")) {
          runs = savedData.runs || 0;
          wickets = savedData.wickets || 0;
          innings = savedData.innings || 1;
          currentInningRuns = savedData.currentInningRuns || 0;
          currentInningWickets = savedData.currentInningWickets || 0;
          batterWickets = savedData.batterWickets || {};
          bowlerOvers = savedData.bowlerOvers || {};
          team1Score = savedData.players?.player1?.score || 0;
          team2Score = savedData.players?.player2?.score || 0;
          batterStats = savedData.batterStats || {};
          bowlerStats = savedData.bowlerStats || {};
          
          await set(ref(db, `savedGames/${room}`), null);
        } else {
          await set(ref(db, `savedGames/${room}`), null);
        }
      }

      const teamsLoaded = await loadPlaying11();
      if (!teamsLoaded) {
        alert("Both teams haven't submitted yet! Returning to team selection.");
        window.location.href = `playing11.html?room=${room}&player=${player}`;
        return;
      }

      const formatSnap = await get(ref(db, `rooms/${room}/player1/format`));
      const format = formatSnap.val() || "5";
      currentFormat = formatRules[format];
      isTestMatch = format === "test";
      
      formatDisplay.innerText = `${currentFormat.name} | ${isTestMatch ? "3 wickets per batter" : "1 wicket per batter"}`;
      
      testControls.style.display = isTestMatch ? "flex" : "none";
      followOnBtn.style.display = "none";
      startInningsBtn.style.display = "none";
      
      await set(ref(db, `rooms/${room}/spectatorData`), {
        overSummaries: {},
        matchStats: {},
        spectatorChat: {}
      });

      initializeBatterStats();

      setupConnectionMonitoring();
      await setupRole();
      setupSelectionModal();
      setupTestControls();
      setupInningsButton();
      updateScoreboard();
      setupFirebaseListeners();
      
      saveBtn.addEventListener("click", saveGameState);
      exitBtn.addEventListener("click", async () => {
        if (confirm("Exit without saving?")) {
          await resetGame();
          window.location.href = "index.html";
        }
      });
      
      resetPlaysBtn.addEventListener("click", async () => {
        if (confirm("Force reset the current plays?")) {
          await resetPlays();
          status.innerText = "Plays manually reset";
        }
      });

      if (localStorage.getItem("aiMode") === "true" && player === "player1") {
        onValue(ref(db, `rooms/${room}/currentPlays/player1`), (snap) => {
          if (snap.exists()) {
            setTimeout(() => {
              const aiCard = Math.floor(Math.random() * 7);
              set(ref(db, `rooms/${room}/currentPlays/player2`), aiCard);
            }, 800);
          }
        });
      }
    }

    // Initialize the game
    initGame();
  </script>
</body>
</html>
