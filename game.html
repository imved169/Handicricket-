<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HandiCricket - Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* Base Styles */
    body { 
      background: #061e3e; 
      color: white; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      text-align: center; 
      padding: 20px;
      margin: 0;
      overflow-x: hidden;
    }
    
    h2 { 
      margin: 10px 0 20px;
      color: #ffeb3b;
      text-shadow: 0 0 5px rgba(255, 235, 59, 0.5);
    }
    
    /* Card Buttons */
    .card-row { 
      margin: 25px auto;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
      max-width: 500px;
      position: relative;
    }
    
    button.card { 
      width: 70px;
      height: 70px;
      font-size: 24px;
      border-radius: 12px;
      border: none;
      background: linear-gradient(145deg, #1e88e5, #1565c0);
      color: white;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.2s;
    }
    
    button.card:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }
    
    button.card:active {
      transform: translateY(1px);
    }
    
    button.card:disabled { 
      background: #607d8b;
      color: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    /* Selection Modal - Positioned above cards */
    .selection-modal { 
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 400px;
      background: linear-gradient(145deg, #123456, #0a1f3a);
      padding: 15px;
      border-radius: 15px;
      margin-bottom: 20px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 100;
      display: none;
    }
    
    .selection-list { 
      max-height: 40vh;
      overflow-y: auto;
      margin: 10px 0;
      padding-right: 5px;
    }
    
    /* Player Items */
    .player-item, .batter-item {
      padding: 10px;
      margin: 5px 0;
      background: rgba(30, 136, 229, 0.2);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      border-left: 3px solid transparent;
    }
    
    .player-item:hover, .batter-item:hover {
      background: rgba(30, 136, 229, 0.4);
      transform: translateX(5px);
    }
    
    .player-item.selected, .batter-item.selected {
      background: rgba(13, 71, 161, 0.6);
      border-left: 3px solid #ffeb3b;
    }
    
    .batter-stats, .bowler-stats {
      font-size: 0.85em;
      color: #aaa;
      margin-top: 3px;
      display: flex;
      justify-content: space-between;
    }
    
    /* Scoreboard and Game Info */
    #scoreboard { 
      background: rgba(13, 42, 82, 0.8);
      padding: 15px;
      border-radius: 10px;
      margin: 15px auto;
      max-width: 500px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      text-align: center;
    }
    
    #scoreboard div {
      padding: 5px;
    }
    
    #scoreboard strong {
      font-size: 1.2em;
      color: #4caf50;
    }
    
    #teamStatus {
      background: rgba(13, 42, 82, 0.8);
      padding: 12px;
      border-radius: 10px;
      margin: 15px auto;
      max-width: 500px;
    }
    
    #currentPlayers {
      display: flex;
      justify-content: space-around;
      margin-bottom: 10px;
    }
    
    #status {
      margin: 15px 0;
      padding: 10px;
      font-size: 18px;
      color: #ffeb3b;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Indicators */
    .free-hit-indicator,
    .powerplay-indicator,
    .dead-over {
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 14px;
      font-weight: bold;
      margin: 0 5px;
      display: inline-block;
    }
    
    .free-hit-indicator {
      background: #4CAF50;
      color: white;
    }
    
    .powerplay-indicator {
      background: #ffeb3b;
      color: #000;
    }
    
    .dead-over {
      background: #f44336;
      color: white;
    }
    
    /* Team Displays */
    #playingXISection {
      margin: 30px auto;
      max-width: 800px;
    }
    
    .team-container {
      display: inline-block;
      vertical-align: top;
      width: 45%;
      min-width: 300px;
      margin: 10px;
      background: rgba(13, 42, 82, 0.6);
      border-radius: 10px;
      padding: 15px;
    }
    
    .team-container h4 {
      margin: 0 0 15px;
      padding-bottom: 5px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .team-container ul {
      list-style: none;
      padding: 0;
      margin: 0;
      text-align: left;
    }
    
    .team-container li {
      padding: 8px 0;
      border-bottom: 1px dotted rgba(255, 255, 255, 0.1);
    }
    
    /* Controls */
    #gameControls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 20px auto;
      justify-content: center;
      max-width: 500px;
    }
    
    #gameControls button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    #saveBtn { 
      background: #FF9800;
      color: white;
    }
    
    #saveBtn:hover {
      background: #F57C00;
    }
    
    #exitBtn { 
      background: #f44336;
      color: white;
    }
    
    #exitBtn:hover {
      background: #d32f2f;
    }
    
    #resetPlaysBtn { 
      background: #9c27b0;
      color: white;
    }
    
    #resetPlaysBtn:hover {
      background: #7b1fa2;
    }
    
    /* Connection Status */
    #connectionStatus {
      padding: 10px;
      border-radius: 8px;
      text-align: center;
      margin: 15px auto;
      max-width: 300px;
      font-weight: bold;
    }
    
    .online { 
      background: #4CAF50;
      color: white;
    }
    
    .offline { 
      background: #F44336;
      color: white;
    }
    
    /* Spectator Elements */
    #spectatorCount {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(30, 136, 229, 0.8);
      padding: 5px 12px;
      border-radius: 15px;
      font-size: 14px;
      z-index: 50;
    }
    
    #miniScorecard {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 8px 15px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 50;
      display: flex;
      gap: 15px;
      align-items: center;
    }
    
    /* Target Display */
    #targetDisplay {
      background: rgba(13, 42, 82, 0.8);
      padding: 12px;
      border-radius: 10px;
      margin: 15px auto;
      max-width: 500px;
      font-weight: bold;
    }
    
    .required-rate {
      color: #ff9800;
    }
    
    /* Animations */
    @keyframes boundary {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    
    @keyframes wicket {
      0% { transform: rotate(0deg); }
      25% { transform: rotate(10deg); }
      50% { transform: rotate(-10deg); }
      75% { transform: rotate(5deg); }
      100% { transform: rotate(0deg); }
    }
    
    .boundary-animation {
      animation: boundary 0.5s ease-in-out;
    }
    
    .wicket-animation {
      animation: wicket 0.7s ease-in-out;
    }
    
    /* Milestone Notifications */
    .milestone-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 15px 25px;
      border-radius: 10px;
      font-size: 20px;
      z-index: 1001;
      animation: fadeInOut 3s forwards;
    }
    
    @keyframes fadeInOut {
      0% { opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    .milestone-notification.batting {
      border-left: 5px solid #4CAF50;
    }
    
    .milestone-notification.bowling {
      border-left: 5px solid #2196F3;
    }
    
    .milestone-notification.error {
      border-left: 5px solid #F44336;
    }
    
    .milestone-notification.info {
      border-left: 5px solid #FFC107;
    }
    
    .milestone-notification.winner {
      border-left: 5px solid #9C27B0;
      font-size: 24px;
    }
    
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background-color: #f00;
      animation: confetti-fall 5s linear forwards;
      z-index: 1000;
    }
    
    @keyframes confetti-fall {
      0% {
        transform: translateY(-100vh) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(360deg);
        opacity: 0;
      }
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .team-container {
        width: 100%;
        min-width: auto;
      }
      
      button.card {
        width: 60px;
        height: 60px;
        font-size: 20px;
      }
      
      #scoreboard {
        grid-template-columns: 1fr 1fr;
      }
      
      .selection-modal {
        width: 95%;
        max-height: 50vh;
      }
    }
    
    @media (max-width: 480px) {
      #scoreboard {
        grid-template-columns: 1fr;
      }
      
      button.card {
        width: 50px;
        height: 50px;
        font-size: 18px;
      }
      
      .selection-modal {
        padding: 10px;
      }
      
      .player-item, .batter-item {
        padding: 8px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div id="spectatorCount">üë• Spectators: 0</div>
  <div id="miniScorecard">
    <div id="miniScore">0/0</div>
    <div id="miniOvers">0.0</div>
  </div>
  
  <h2>üèè HandiCricket</h2>
  <div id="formatDisplay"></div>
  <div id="roleText"></div>
  
  <div id="teamStatus">
    <div id="currentPlayers">
      <div>Batter: <span id="currentBatter">-</span></div>
      <div>Bowler: <span id="currentBowler">-</span></div>
    </div>
    <div id="scoreboard">
      <div>Runs: <strong>0</strong></div>
      <div>Wickets: <strong>0/11</strong></div>
      <div>Overs: <strong>0.0</strong></div>
    </div>
  </div>
  
  <div id="targetDisplay" style="display: none;">
    <div class="target-text">Target: <span id="targetRuns">0</span> runs | <span id="requiredRate" class="required-rate">RR: 0.00</span></div>
  </div>
  
  <div id="status">Initializing game...</div>

  <div class="card-row" id="cardButtons">
    <!-- Selection Modal - Now positioned above the cards -->
    <div id="selectionModal" class="selection-modal">
      <h3 id="selectionTitle">Select Next Batter</h3>
      <div id="selectionList" class="selection-list"></div>
      <button id="confirmSelection" style="width: 100%; margin-top: 10px; padding: 8px; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer;">Confirm</button>
    </div>
    
    <!-- Card buttons -->
    <button class="card" data-value="0">0</button>
    <button class="card" data-value="1">1</button>
    <button class="card" data-value="2">2</button>
    <button class="card" data-value="3">3</button>
    <button class="card" data-value="4">4</button>
    <button class="card" data-value="5">5</button>
    <button class="card" data-value="6">6</button>
  </div>

  <button id="startInningsBtn" style="display: none;">
    <div id="startInningsText">Start Second Innings</div>
    <div id="opponentReadyStatus" style="display: none;">
      <span>‚úì Opponent Ready</span>
    </div>
    <div id="autoStartTimer" style="display: none;"></div>
  </button>

  <div id="playingXISection">
    <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 20px;">
      <div class="team-container">
        <h4 id="team1Name">Team 1</h4>
        <ul id="team1Players"></ul>
      </div>
      <div class="team-container">
        <h4 id="team2Name">Team 2</h4>
        <ul id="team2Players"></ul>
      </div>
    </div>
  </div>

  <div id="gameControls">
    <button id="saveBtn">üíæ Save & Exit</button>
    <button id="exitBtn">üö™ Exit Without Saving</button>
    <button id="resetPlaysBtn">üîÑ Reset Plays</button>
  </div>
  
  <div id="connectionStatus" class="online">
    Opponent: Online
  </div>

  <script type="module">
    // Import Firebase modules from your configuration
    import { db, ref, onValue, set, get, update, push, remove, child } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-database.js";

    // Get URL parameters
    const params = new URLSearchParams(window.location.search);
    const room = params.get('room');
    const player = params.get('player');
    const opponent = player === "player1" ? "player2" : "player1";

    // Game format rules
    const formatRules = {
      "5": { 
        name: "5 Overs", 
        totalOvers: 5, 
        totalWickets: 11, 
        powerplayOvers: 2, 
        powerplayWicketValue: 0.5,
        regularWicketValue: 1.0,
        livesPerPlayer: 2,
        deadOvers: []
      },
      "10": { 
        name: "10 Overs", 
        totalOvers: 10, 
        totalWickets: 11, 
        powerplayOvers: 3, 
        powerplayWicketValue: 0.5,
        regularWicketValue: 1.0,
        livesPerPlayer: 2,
        deadOvers: []
      },
      "20": { 
        name: "T20", 
        totalOvers: 20, 
        totalWickets: 11, 
        powerplayOvers: 6, 
        powerplayWicketValue: 0.5,
        regularWicketValue: 1.0,
        livesPerPlayer: 2,
        deadOvers: []
      },
      "50": { 
        name: "ODI", 
        totalOvers: 50, 
        totalWickets: 11, 
        powerplayOvers: [1,10, 21,30, 41,42], 
        powerplayWicketValue: 0.25,
        regularWicketValue: 0.5,
        livesPerPlayer: 4,
        deadOvers: [11,20, 31,40]
      },
      "test": { 
        name: "Test Match", 
        totalOvers: Infinity, 
        totalWickets: 30, 
        powerplayOvers: 0, 
        powerplayWicketValue: 0.33,
        regularWicketValue: 0.33,
        livesPerPlayer: 3,
        deadOvers: []
      }
    };

    // Game state variables
    let runs = 0, wickets = 0;
    let legalBalls = 0;
    let freeHit = false;
    let freeHitNextBall = false;
    let currentBatter = null;
    let currentBowler = null;
    let battersUsed = [];
    let bowlersUsed = [];
    let bowlerOvers = {};
    let isBatting = false;
    let currentFormat = {};
    let isTestMatch = false;
    let innings = 1;
    let currentInningRuns = 0;
    let currentInningWickets = 0;
    let team1Score = 0;
    let team2Score = 0;
    let team1Wickets = 0;
    let team2Wickets = 0;
    let daysRemaining = 5;
    let oversToday = 0;
    const maxOversPerDay = 90;
    let isPowerplay = false;
    let isDeadOver = false;
    let batterWickets = {};
    let zerosThisOver = { player1: 0, player2: 0 };
    let bowlerRuns = {};
    let gameInProgress = true;
    let lastOverRuns = 0;
    let lastOverWickets = 0;
    let lastWicketScore = 0;
    let ballByBall = {};
    let fallOfWickets = [];
    let batterStats = {};
    let bowlerStats = {};
    let autoStartTimer;
    let countdownInterval;
    let tossWinner = null;
    let battingFirst = null;
    const milestoneLevels = [50, 100, 150, 200, 250, 300, 350, 400];
    let batterSelected = false;
    let bowlerSelected = false;

    // DOM elements
    const status = document.getElementById("status");
    const scoreboard = document.getElementById("scoreboard");
    const buttons = document.querySelectorAll(".card");
    const roleText = document.getElementById("roleText");
    const currentBatterEl = document.getElementById("currentBatter");
    const currentBowlerEl = document.getElementById("currentBowler");
    const selectionModal = document.getElementById("selectionModal");
    const selectionTitle = document.getElementById("selectionTitle");
    const selectionList = document.getElementById("selectionList");
    const confirmSelection = document.getElementById("confirmSelection");
    const team1NameEl = document.getElementById("team1Name");
    const team2NameEl = document.getElementById("team2Name");
    const team1PlayersEl = document.getElementById("team1Players");
    const team2PlayersEl = document.getElementById("team2Players");
    const formatDisplay = document.getElementById("formatDisplay");
    const saveBtn = document.getElementById("saveBtn");
    const exitBtn = document.getElementById("exitBtn");
    const resetPlaysBtn = document.getElementById("resetPlaysBtn");
    const connectionStatus = document.getElementById("connectionStatus");
    const spectatorCountEl = document.getElementById("spectatorCount");
    const targetDisplay = document.getElementById("targetDisplay");
    const targetRunsEl = document.getElementById("targetRuns");
    const requiredRateEl = document.getElementById("requiredRate");
    const miniScoreEl = document.getElementById("miniScore");
    const miniOversEl = document.getElementById("miniOvers");
    const startInningsBtn = document.getElementById("startInningsBtn");
    const opponentReadyStatus = document.getElementById("opponentReadyStatus");
    const autoStartTimerEl = document.getElementById("autoStartTimer");
    const startInningsText = document.getElementById("startInningsText");

    // Firebase references
    const playerRef = ref(db, `rooms/${room}/${player}/online`);
    const opponentRef = ref(db, `rooms/${room}/${opponent}/online`);
    const roomRef = ref(db, `rooms/${room}`);
    const playsRef = ref(db, `rooms/${room}/currentPlays`);
    const batterRef = ref(db, `rooms/${room}/currentBatter`);
    const bowlerRef = ref(db, `rooms/${room}/currentBowler`);
    const inningsReadyRef = ref(db, `rooms/${room}/inningsReady`);
    const autoStartTimeRef = ref(db, `rooms/${room}/autoStartTime`);
    const startSecondInningsRef = ref(db, `rooms/${room}/startSecondInnings`);
    const declaredRef = ref(db, `rooms/${room}/declared`);
    const followOnRef = ref(db, `rooms/${room}/followOn`);
    const spectatorsRef = ref(db, `rooms/${room}/spectators`);
    const reactionsRef = ref(db, `rooms/${room}/reactions`);
    const matchStatsRef = ref(db, `rooms/${room}/matchStats`);
    const liveStateRef = ref(db, `rooms/${room}/liveState`);
    const overSummariesRef = ref(db, `rooms/${room}/overSummaries`);
    const resultRef = ref(db, `rooms/${room}/result`);
    const savedGameRef = ref(db, `savedGames/${room}`);

    // Initialize batter stats with milestone tracking
    function initializeBatterStats() {
      get(roomRef).then(snapshot => {
        const data = snapshot.val();
        
        if (data.player1?.playing11) {
          data.player1.playing11.forEach(player => {
            batterStats[player] = { 
              runs: 0, 
              balls: 0,
              fours: 0,
              sixes: 0,
              centuryNotified: false,
              fiftyNotified: false
            };
            batterWickets[player] = 0;
            milestoneLevels.forEach(level => {
              batterStats[player][`milestone${level}Notified`] = false;
            });
          });
        }
        
        if (data.player2?.playing11) {
          data.player2.playing11.forEach(player => {
            batterStats[player] = { 
              runs: 0, 
              balls: 0,
              fours: 0,
              sixes: 0,
              centuryNotified: false,
              fiftyNotified: false
            };
            batterWickets[player] = 0;
            milestoneLevels.forEach(level => {
              batterStats[player][`milestone${level}Notified`] = false;
            });
          });
        }
      }).catch(error => {
        console.error("Error initializing batter stats:", error);
      });
    }

    // Check for batting milestones (50, 100, 150, etc.)
    function checkBattingMilestones() {
      if (!currentBatter) return;

      const batterRuns = batterStats[currentBatter]?.runs || 0;
      
      // Check for 50, 100, etc.
      for (const milestone of milestoneLevels) {
        if (batterRuns >= milestone && 
            !batterStats[currentBatter][`milestone${milestone}Notified`]) {
          
          showNotification(`${currentBatter} scores ${milestone} runs! üéâ`, 'batting');
          batterStats[currentBatter][`milestone${milestone}Notified`] = true;
          
          if (milestone >= 150) {
            createConfetti();
          }
          break;
        }
      }
      
      // Special handling for 50 and 100
      if (batterRuns >= 50 && !batterStats[currentBatter].fiftyNotified) {
        showNotification(`${currentBatter} scores a half-century!`, 'batting');
        batterStats[currentBatter].fiftyNotified = true;
      }
      
      if (batterRuns >= 100 && !batterStats[currentBatter].centuryNotified) {
        showNotification(`${currentBatter} scores a century! üíØ`, 'batting');
        batterStats[currentBatter].centuryNotified = true;
        createConfetti();
      }
    }

    // Show notification with different styles
    function showNotification(message, type = 'info') {
      const notif = document.createElement('div');
      notif.className = `milestone-notification ${type}`;
      notif.textContent = message;
      document.body.appendChild(notif);
      
      // Position randomly but within view
      notif.style.left = `${Math.random() * 60 + 20}%`;
      notif.style.top = `${Math.random() * 60 + 20}%`;
      
      setTimeout(() => {
        notif.style.opacity = '0';
        setTimeout(() => notif.remove(), 500);
      }, 2500);
    }

    // Create confetti effect
    function createConfetti() {
      const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
      for (let i = 0; i < 150; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = `${Math.random() * 100}%`;
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.width = `${Math.random() * 10 + 5}px`;
        confetti.style.height = `${Math.random() * 10 + 5}px`;
        confetti.style.animationDuration = `${Math.random() * 3 + 2}s`;
        confetti.style.animationDelay = `${Math.random() * 0.5}s`;
        document.body.appendChild(confetti);
        setTimeout(() => confetti.remove(), 5000);
      }
    }

    // Function to start the second innings
    async function startSecondInnings() {
      try {
        disableButtons();
        status.innerText = "Starting second innings...";
        
        if (countdownInterval) clearInterval(countdownInterval);
        
        await set(startSecondInningsRef, true);
        
        // Reset game state for new innings
        await update(roomRef, {
          currentPlays: { player1: null, player2: null },
          currentBatter: null,
          currentBowler: null,
          inningsReady: null,
          autoStartTime: null
        });
        
        innings++;
        startInningsBtn.style.display = "none";
        resetInning();
      } catch (error) {
        console.error("Error starting second innings:", error);
        status.innerText = "Error starting second innings. Please try again.";
        enableButtons();
      }
    }

    // Update spectator data with match details
    function updateSpectatorData() {
      const currentOver = Math.floor(legalBalls / 6);
      
      // Update over summaries
      if (currentOver > lastOverRuns) {
        const overSummary = `Over ${currentOver}: ${runs - lastOverRuns} runs, ${wickets - lastOverWickets} wickets`;
        set(ref(db, `${overSummariesRef.path}/${currentOver}`), overSummary);
        lastOverRuns = runs;
        lastOverWickets = wickets;
      }

      // Calculate match stats
      const runRate = legalBalls > 0 ? (runs / (legalBalls / 6)).toFixed(2) : "0.00";
      const boundaries = Object.values(ballByBall).filter(ball => [4,6].includes(ball.runs)).length;
      const requiredRate = innings === 2 ? ((team1Score - runs + 1) / Math.max(1, (currentFormat.totalOvers * 6 - legalBalls) / 6)).toFixed(2) : null;

      // Update match stats
      set(matchStatsRef, {
        runRate: runRate,
        boundaries: boundaries,
        dotBalls: Object.values(ballByBall).filter(ball => ball.runs === 0).length,
        wickets: Math.floor(wickets),
        partnership: runs - lastWicketScore,
        requiredRate: requiredRate,
        currentOver: `${currentOver}.${legalBalls % 6}`,
        isPowerplay: isPowerplay,
        isDeadOver: isDeadOver,
        freeHit: freeHit,
        fallOfWickets: fallOfWickets.slice(-5)
      });

      // Update live state
      set(liveStateRef, {
        runs: runs,
        wickets: Math.floor(wickets),
        legalBalls: legalBalls,
        currentBatter: currentBatter,
        currentBowler: currentBowler,
        isPowerplay: isPowerplay,
        isDeadOver: isDeadOver,
        freeHit: freeHit,
        innings: innings,
        timestamp: Date.now()
      });
    }

    // Update free hit display
    function updateFreeHitDisplay() {
      const freeHitIndicator = document.getElementById("freeHitIndicator");
      const freeHitAlert = document.getElementById("freeHitAlert");
      
      if (freeHit) {
        freeHitIndicator.style.display = "inline-block";
        freeHitAlert.style.display = "block";
        document.getElementById("status").classList.add("free-hit");
      } else {
        freeHitIndicator.style.display = "none";
        freeHitAlert.style.display = "none";
        document.getElementById("status").classList.remove("free-hit");
      }
    }

    // Update target display for 2nd innings
    function updateTargetDisplay() {
      if (innings === 2) {
        targetDisplay.style.display = "block";
        targetRunsEl.textContent = team1Score + 1;
        
        const ballsRemaining = currentFormat.totalOvers * 6 - legalBalls;
        if (ballsRemaining > 0) {
          const requiredRuns = team1Score - runs + 1;
          const requiredRate = (requiredRuns / (ballsRemaining / 6)).toFixed(2);
          requiredRateEl.textContent = `RR: ${requiredRate}`;
        } else {
          requiredRateEl.textContent = "";
        }
      } else {
        targetDisplay.style.display = "none";
      }
    }

    // Update mini scorecard
    function updateMiniScorecard() {
      miniScoreEl.textContent = `${runs}/${Math.floor(wickets)}`;
      miniOversEl.textContent = `${Math.floor(legalBalls/6)}.${legalBalls%6}`;
    }

    // Update momentum meter
    function updateMomentum() {
      const boundaryCount = Object.values(ballByBall)
        .filter(ball => ball.runs >= 4).length;
      const meter = document.querySelector('.meter-bar');
      const momentum = Math.min(100, boundaryCount * 5);
      meter.style.width = `${momentum}%`;
      meter.style.backgroundColor = momentum > 70 ? '#4CAF50' : 
                                  momentum > 30 ? '#FFC107' : '#F44336';
    }

    // Check for milestones (centuries, 5-wicket hauls)
    function checkMilestones() {
      if (currentBatter && batterStats[currentBatter]?.runs >= 100 && 
          !batterStats[currentBatter].centuryNotified) {
        showNotification(`${currentBatter} scores a century! üéâ`, 'batting');
        batterStats[currentBatter].centuryNotified = true;
        createConfetti();
      }
      
      if (currentBowler && bowlerStats[currentBowler]?.wickets >= 5 && 
          !bowlerStats[currentBowler].fiveWicketNotified) {
        showNotification(`${currentBowler} takes 5 wickets! üéØ`, 'bowling');
        bowlerStats[currentBowler].fiveWicketNotified = true;
        createConfetti();
      }
    }

    // Load playing 11 from Firebase
    async function loadPlaying11() {
      try {
        const snapshot = await get(roomRef);
        const data = snapshot.val();

        if (!data) {
          showNotification("Room data not loaded yet", 'info');
          return false;
        }

        // Only require our own team to be loaded initially
        if (data[player]?.playing11) {
          team1NameEl.innerText = data.player1?.teamName || "Team 1";
          team2NameEl.innerText = data.player2?.teamName || "Team 2";
          
          // Load our team
          const ourTeamEl = player === "player1" ? team1PlayersEl : team2PlayersEl;
          ourTeamEl.innerHTML = data[player].playing11.map(p => `<li>${p}</li>`).join("");
          
          // Load opponent team if available
          const opponentTeamEl = player === "player1" ? team2PlayersEl : team1PlayersEl;
          if (data[opponent]?.playing11) {
            opponentTeamEl.innerHTML = data[opponent].playing11.map(p => `<li>${p}</li>`).join("");
          }
          
          return true;
        }
        return false;
      } catch (error) {
        console.error("Error loading playing XI:", error);
        showNotification("Error loading teams", 'error');
        return false;
      }
    }

    // Monitor connection status
    function setupConnectionMonitoring() {
      // Set initial online status
      set(playerRef, { 
        status: true, 
        timestamp: Date.now(),
        playerName: player,
        teamName: player === "player1" ? team1NameEl.textContent : team2NameEl.textContent
      });
      
      const connectionTimeout = 15000;
      let disconnectTimer;
      
      onValue(opponentRef, (snap) => {
        if (!snap.exists() || !snap.val()) {
          // Opponent disconnected
          connectionStatus.textContent = "Opponent: Offline (Game Paused)";
          connectionStatus.className = "offline";
          disableButtons();
          
          // Start disconnect timer
          clearTimeout(disconnectTimer);
          disconnectTimer = setTimeout(() => {
            status.textContent = "Opponent disconnected - game will end soon";
          }, 30000);
        } else {
          // Opponent is online
          clearTimeout(disconnectTimer);
          const lastSeen = snap.val().timestamp || 0;
          const timeDiff = Date.now() - lastSeen;
          
          if (timeDiff > connectionTimeout) {
            connectionStatus.textContent = "Opponent: Lagging (Slow Connection)";
            connectionStatus.className = "offline";
            disableButtons();
          } else {
            connectionStatus.textContent = "Opponent: Online";
            connectionStatus.className = "online";
            if (!selectionModal.style.display || selectionModal.style.display === "none") {
              updateButtonStates();
            }
          }
        }
      });
      
      // Update our online status periodically
      setInterval(() => {
        set(playerRef, { 
          status: true, 
          timestamp: Date.now(),
          playerName: player,
          teamName: player === "player1" ? team1NameEl.textContent : team2NameEl.textContent
        });
      }, 5000);
      
      // Clean up on page unload
      window.addEventListener('beforeunload', () => {
        set(playerRef, { 
          status: false, 
          timestamp: Date.now(),
          playerName: player,
          teamName: player === "player1" ? team1NameEl.textContent : team2NameEl.textContent
        });
      });
    }

    // Handle back button
    function setupBackButtonHandling() {
      window.addEventListener('beforeunload', (e) => {
        if (gameInProgress) {
          e.preventDefault();
          e.returnValue = 'Are you sure you want to leave? Your progress may be lost.';
          return e.returnValue;
        }
      });
      
      if (window.history && window.history.pushState) {
        window.history.pushState('forward', null, './');
        window.onpopstate = function() {
          if (confirm("Exit game? Your progress will be lost unless saved.")) {
            resetGame();
            window.location.href = "index.html";
          } else {
            window.history.pushState('forward', null, './');
          }
        };
      }
    }

    // Save game state
    async function saveGameState() {
      try {
        const gameState = {
          timestamp: Date.now(),
          players: {
            player1: { 
              team: team1NameEl.textContent,
              score: team1Score,
              wickets: team1Wickets
            },
            player2: { 
              team: team2NameEl.textContent,
              score: team2Score,
              wickets: team2Wickets
            }
          },
          innings: innings,
          currentBatter: currentBatter,
          currentBowler: currentBowler,
          ballsRemaining: currentFormat.totalOvers * 6 - legalBalls,
          batterWickets: batterWickets,
          bowlerOvers: bowlerOvers,
          runs: runs,
          wickets: wickets,
          currentInningRuns: currentInningRuns,
          currentInningWickets: currentInningWickets,
          batterStats: batterStats,
          bowlerStats: bowlerStats,
          fallOfWickets: fallOfWickets,
          format: currentFormat.name
        };
        
        await set(savedGameRef, gameState);
        await set(playerRef, false);
        showNotification("Game saved successfully!", 'info');
        setTimeout(() => window.location.href = "index.html", 1500);
      } catch (error) {
        console.error("Error saving game:", error);
        showNotification("Failed to save game", 'error');
      }
    }

    // Reset game state
    async function resetGame() {
      try {
        await update(roomRef, {
          currentPlays: null,
          currentBatter: null,
          currentBowler: null,
          inningsReady: null,
          startSecondInnings: null,
          autoStartTime: null,
          declared: null,
          followOn: null
        });
        await set(playerRef, false);
      } catch (error) {
        console.error("Error resetting game:", error);
      }
    }

    // Update button states based on selection status
    function updateButtonStates() {
      const bothReady = batterSelected && bowlerSelected;
      
      buttons.forEach(btn => {
        btn.disabled = !bothReady;
        btn.style.opacity = bothReady ? '1' : '0.6';
      });

      status.innerText = bothReady ? 
        (freeHit ? "FREE HIT! Play your card..." : "Play your card...") :
        "Waiting for batter/bowler selection...";
    }

    // Disable all card buttons
    function disableButtons() {
      buttons.forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.6';
      });
      if (startInningsBtn.style.display !== "none") {
        startInningsBtn.disabled = true;
      }
    }

    // Enable all card buttons if both players are selected
    function enableButtons() {
      if (batterSelected && bowlerSelected) {
        buttons.forEach(btn => {
          btn.disabled = false;
          btn.style.opacity = '1';
        });
        if (startInningsBtn.style.display !== "none") {
          startInningsBtn.disabled = false;
        }
      }
    }

    // Check powerplay status based on current over
    function checkPowerplayStatus() {
      const currentOver = Math.floor(legalBalls / 6);
      
      isPowerplay = false;
      isDeadOver = false;
      
      if (isTestMatch) return;

      // Handle array-based powerplay overs (for ODI format)
      if (Array.isArray(currentFormat.powerplayOvers)) {
        for (let i = 0; i < currentFormat.powerplayOvers.length; i += 2) {
          const startOver = currentFormat.powerplayOvers[i] - 1;
          const endOver = currentFormat.powerplayOvers[i+1] - 1;
          
          if (currentOver >= startOver && currentOver <= endOver) {
            isPowerplay = true;
            break;
          }
        }
      } 
      // Handle simple powerplay (first X overs)
      else if (currentOver < currentFormat.powerplayOvers) {
        isPowerplay = true;
      }

      // Check for dead overs (ODI format)
      if (Array.isArray(currentFormat.deadOvers) && currentFormat.deadOvers.length > 0) {
        for (let i = 0; i < currentFormat.deadOvers.length; i += 2) {
          const startOver = currentFormat.deadOvers[i] - 1;
          const endOver = currentFormat.deadOvers[i+1] - 1;
          
          if (currentOver >= startOver && currentOver <= endOver) {
            isDeadOver = true;
            break;
          }
        }
      }

      updateFreeHitDisplay();
    }

    // Update scoreboard display
    function updateScoreboard() {
      const overs = Math.floor(legalBalls / 6);
      const balls = legalBalls % 6;
      const displayWickets = Math.floor(wickets);
      const totalWickets = currentFormat.totalWickets;
      
      // Basic score display
      let scoreHTML = `
        <div>Runs: <strong>${runs}</strong></div>
        <div>Wickets: <strong>${displayWickets}/${totalWickets}</strong></div>
        <div>Overs: <strong>${overs}.${balls}</strong></div>
      `;

      // Add format-specific info
      if (isTestMatch) {
        const currentDay = 6 - daysRemaining;
        scoreHTML += `
          <div><strong>Innings ${innings}/4</strong></div>
          <div>Day ${currentDay}/5</div>
          <div>Team 1: ${team1Score}/${Math.floor(team1Wickets)}</div>
          <div>Team 2: ${team2Score}/${Math.floor(team2Wickets)}</div>
          <div>Overs today: ${oversToday}/${maxOversPerDay}</div>
        `;
      } else {
        const remainingBalls = (currentFormat.totalOvers * 6) - legalBalls;
        const remainingOvers = Math.floor(remainingBalls / 6) + (remainingBalls % 6) / 10;
        
        scoreHTML += `
          <div>Remaining: ${remainingBalls} balls</div>
          <div>Run Rate: ${(runs / (legalBalls / 6)).toFixed(2)}</div>
        `;

        // Powerplay info
        if (currentFormat.powerplayOvers > 0) {
          const powerplayDone = Array.isArray(currentFormat.powerplayOvers) ? 
            currentOver >= currentFormat.powerplayOvers[currentFormat.powerplayOvers.length - 1] :
            currentOver >= currentFormat.powerplayOvers;
            
          scoreHTML += `<div>Powerplay: ${powerplayDone ? 'Completed' : 'Active'}</div>`;
        }

        // Target info for second innings
        if (innings === 2) {
          const target = team1Score + 1;
          const needed = target - runs;
          const ballsRemaining = currentFormat.totalOvers * 6 - legalBalls;
          const requiredRate = ballsRemaining > 0 ? (needed / (ballsRemaining / 6)).toFixed(2) : 0;
          
          scoreHTML += `
            <div>Target: <strong>${target}</strong></div>
            <div>Need: ${needed} runs in ${ballsRemaining} balls</div>
            <div>Req. Rate: <strong>${requiredRate}</strong></div>
          `;
        }
      }

      // Add indicators for special overs
      if (isPowerplay) {
        scoreHTML += '<div class="powerplay-indicator">POWERPLAY</div>';
      }
      if (isDeadOver) {
        scoreHTML += '<div class="dead-over">DEAD OVER</div>';
      }
      if (freeHit) {
        scoreHTML += '<div class="free-hit-indicator">FREE HIT</div>';
      }

      scoreboard.innerHTML = scoreHTML;
      updateMiniScorecard();
      updateTargetDisplay();
      updateMomentum();
    }

    // Reset plays after each ball
    async function resetPlays() {
      try {
        await update(playsRef, {
          player1: null,
          player2: null
        });
        enableButtons();
      } catch (error) {
        console.error("Error resetting plays:", error);
        enableButtons();
      }
    }

    // Set up player roles (batting/bowling)
    async function setupRole() {
      try {
        const [tossSnap, battingFirstSnap, decisionSnap, teamSnap] = await Promise.all([
          get(ref(db, `rooms/${room}/tossWinner`)),
          get(ref(db, `rooms/${room}/battingFirst`)),
          get(ref(db, `rooms/${room}/decision`)),
          get(ref(db, `rooms/${room}/${opponent}/playing11`))
        ]);
        
        tossWinner = tossSnap.val();
        battingFirst = battingFirstSnap.val();
        const decision = decisionSnap.val();
        const opponentTeam = teamSnap.val()?.[0] || "Opponent";

        isBatting = (innings % 2 === 1) ? (player === battingFirst) : (player !== battingFirst);

        roleText.innerText = isBatting ? 
          `You are Batting (${decision === 'bat' ? 'chose to bat' : 'chose to bowl'}) vs ${opponentTeam}` : 
          `You are Bowling (${decision === 'bowl' ? 'chose to bowl' : 'chose to bat'}) vs ${opponentTeam}`;

        currentBatterEl.innerText = "-";
        currentBowlerEl.innerText = "-";

        // Disable buttons until selections are made
        batterSelected = false;
        bowlerSelected = false;
        updateButtonStates();

        if (isBatting && !currentBatter) {
          showBatterSelection();
        } else if (!isBatting && !currentBowler) {
          showBowlerSelection();
        }
      } catch (error) {
        console.error("Error setting up role:", error);
        showNotification("Error determining your role", 'error');
      }
    }

    // Set up selection modal for batters/bowlers
    function setupSelectionModal() {
      confirmSelection.addEventListener("click", async () => {
        const selectedPlayer = document.querySelector(".batter-item.selected") || 
                             document.querySelector(".player-item.selected");
        if (!selectedPlayer) {
          showNotification("Please select a player", 'error');
          return;
        }

        const playerName = selectedPlayer.dataset.name;
        const selectionType = selectionTitle.textContent.includes("Batter") ? "batter" : "bowler";

        try {
          if (selectionType === "batter") {
            currentBatter = playerName;
            if (!battersUsed.includes(playerName)) {
              battersUsed.push(playerName);
            }
            batterWickets[playerName] = batterWickets[playerName] || 0;
            currentBatterEl.innerText = playerName;
            await set(batterRef, playerName);
            batterSelected = true;
          } else {
            currentBowler = playerName;
            bowlerOvers[playerName] = bowlerOvers[playerName] || 0;
            currentBowlerEl.innerText = playerName;
            await set(bowlerRef, playerName);
            bowlerSelected = true;
          }

          selectionModal.style.display = "none";
          updateButtonStates();
        } catch (error) {
          console.error("Error confirming selection:", error);
          showNotification("Error selecting player", 'error');
        }
      });
    }

    // Enhanced batter selection modal
    async function showBatterSelection() {
      disableButtons();
      try {
        status.innerText = "Loading batters...";
        
        // Verify room data exists first
        const roomSnap = await get(roomRef);
        if (!roomSnap.exists() || !roomSnap.val()[player]) {
          showNotification("Game data not loaded", 'error');
          enableButtons();
          return;
        }

        // Get player data
        const snapshot = await get(ref(db, `rooms/${room}/${player}/playing11`));
        const players = snapshot.val();
        
        if (!players || players.length === 0) {
          showNotification("No batters available", 'error');
          enableButtons();
          return;
        }
        
        // Filter available batters
        const availableBatters = players.filter(p => {
          const wicketsUsed = batterWickets[p] || 0;
          return !battersUsed.includes(p) || wicketsUsed < 1.0;
        });
        
        if (availableBatters.length === 0) {
          showNotification("All batters are out!", 'error');
          enableButtons();
          return;
        }

        // Update selection UI
        selectionTitle.textContent = "Select Next Batter";
        selectionList.innerHTML = "";
        
        availableBatters.forEach(player => {
          const stats = batterStats[player] || { runs: 0, balls: 0, fours: 0, sixes: 0 };
          const wicketsLost = batterWickets[player] || 0;
          const strikeRate = stats.balls > 0 ? (stats.runs / stats.balls * 100).toFixed(2) : "0.00";
          const wicketsLeft = (1.0 - wicketsLost).toFixed(2);
          
          const batterEl = document.createElement("div");
          batterEl.className = "batter-item";
          batterEl.dataset.name = player;
          batterEl.innerHTML = `
            <div>${player}</div>
            <div class="batter-stats">
              <div class="batter-status">
                <span>${stats.runs} runs</span>
                <span>${stats.balls} balls</span>
                <span>SR: ${strikeRate}</span>
              </div>
              <div class="batter-status">
                <span>${stats.fours} fours</span>
                <span>${stats.sixes} sixes</span>
                <span>${wicketsLeft}/1.0 wickets</span>
              </div>
            </div>
          `;
          
          batterEl.addEventListener("click", function() {
            document.querySelectorAll(".batter-item").forEach(el => el.classList.remove("selected"));
            this.classList.add("selected");
          });
          
          selectionList.appendChild(batterEl);
        });

        // Show modal above cards
        selectionModal.style.display = "block";
        status.innerText = "Select your next batter...";
      } catch (error) {
        console.error("Batter selection error:", error);
        showNotification("Error loading batters", 'error');
        enableButtons();
      }
    }

    // Show bowler selection modal
    async function showBowlerSelection() {
      disableButtons();
      try {
        status.innerText = "Loading bowlers...";
        
        const snapshot = await get(ref(db, `rooms/${room}/${player}/playing11`));
        const players = snapshot.val();
        
        if (!players || players.length === 0) {
          showNotification("No bowlers available", 'error');
          enableButtons();
          return;
        }
        
        const maxOversPerBowler = isTestMatch ? Infinity : Math.ceil(currentFormat.totalOvers / 5);
        const availableBowlers = players.filter(p => (bowlerOvers[p] || 0) < maxOversPerBowler);
        
        if (availableBowlers.length === 0) {
          showNotification("All bowlers have bowled their maximum overs!", 'error');
          enableButtons();
          return;
        }

        selectionTitle.textContent = "Select Next Bowler";
        selectionList.innerHTML = "";
        
        availableBowlers.forEach(player => {
          const oversBowled = bowlerOvers[player] || 0;
          const stats = bowlerStats[player] || { wickets: 0, runs: 0 };
          const economy = oversBowled > 0 ? (stats.runs / oversBowled).toFixed(2) : "0.00";
          
          const playerEl = document.createElement("div");
          playerEl.className = "player-item";
          playerEl.dataset.name = player;
          playerEl.innerHTML = `
            <div>${player}</div>
            <div class="bowler-stats">
              <div>${oversBowled.toFixed(1)} overs</div>
              <div>${stats.wickets} wickets</div>
              <div>ER: ${economy}</div>
            </div>
          `;
          
          playerEl.addEventListener("click", function() {
            document.querySelectorAll(".player-item").forEach(el => el.classList.remove("selected"));
            this.classList.add("selected");
          });
          
          selectionList.appendChild(playerEl);
        });

        // Show modal above cards
        selectionModal.style.display = "block";
        status.innerText = "Select your next bowler...";
      } catch (error) {
        console.error("Bowler selection error:", error);
        showNotification("Error loading bowlers", 'error');
        enableButtons();
      }
    }

    // Set up test match controls
    function setupTestControls() {
      const declareBtn = document.getElementById("declareInning");
      const followOnBtn = document.getElementById("enforceFollowOn");
      
      if (!declareBtn || !followOnBtn) return;
      
      declareBtn.addEventListener("click", async () => {
        if (confirm("Are you sure you want to declare this innings?")) {
          try {
            disableButtons();
            status.innerText = "Innings declared!";
            
            if (innings === 1) {
              team1Score = currentInningRuns;
              team1Wickets = wickets;
            } else {
              team2Score = currentInningRuns;
              team2Wickets = wickets;
            }
            
            await set(declaredRef, true);
            endInning();
          } catch (error) {
            console.error("Error declaring innings:", error);
            showNotification("Error declaring innings", 'error');
            enableButtons();
          }
        }
      });

      followOnBtn.addEventListener("click", async () => {
        const lead = team1Score - team2Score;
        if (confirm(`Enforce follow-on with a lead of ${lead} runs?`)) {
          try {
            disableButtons();
            status.innerText = "Follow-on enforced!";
            
            innings = 2;
            await set(followOnRef, false);
            resetInning();
            
            followOnBtn.style.display = "none";
          } catch (error) {
            console.error("Error enforcing follow-on:", error);
            showNotification("Error enforcing follow-on", 'error');
            enableButtons();
          }
        }
      });
    }

    // Set up the innings button with enhanced functionality
    function setupInningsButton() {
      startInningsBtn.addEventListener("click", startSecondInnings);

      onValue(inningsReadyRef, (snap) => {
        if (!snap.exists()) return;
        
        const isReady = snap.val();
        
        if (isReady && innings === 1 && !isTestMatch) {
          opponentReadyStatus.style.display = "flex";
          startInningsText.textContent = "Ready to Start";
          startInningsBtn.disabled = false;
          
          status.innerText = `Team 1 scored ${team1Score} runs! Opponent is ready to start second innings.`;
        }
      });

      onValue(autoStartTimeRef, (snap) => {
        if (!snap.exists() || !snap.val()) {
          autoStartTimerEl.style.display = "none";
          return;
        }
        
        const startTime = snap.val();
        const now = Date.now();
        
        if (startTime > now) {
          autoStartTimerEl.style.display = "block";
          
          if (countdownInterval) clearInterval(countdownInterval);
          countdownInterval = setInterval(() => {
            const remaining = Math.max(0, Math.ceil((startTime - Date.now()) / 1000));
            autoStartTimerEl.textContent = `Auto-start in ${remaining}s`;
            
            if (remaining <= 0) {
              clearInterval(countdownInterval);
              autoStartTimerEl.style.display = "none";
            }
          }, 1000);
        }
      });

      onValue(startSecondInningsRef, (snap) => {
        if (snap.exists() && snap.val() && innings === 1 && !isTestMatch) {
          innings++;
          startInningsBtn.style.display = "none";
          resetInning();
        }
      });
    }

    // Process the outcome of a ball
    async function processBallOutcome(batCard, bowlCard, battingPlayer, bowlingPlayer) {
      let outcome = "";
      let isLegalBall = false;
      let isWicket = false;
      let isPlayerOut = false;
      let runsScored = 0;
      let boundary = false;
      let isSix = false;

      // Track zeros for both players
      if (batCard === 0) zerosThisOver[battingPlayer]++;
      if (bowlCard === 0) zerosThisOver[bowlingPlayer]++;

      // Handle free hit for next ball
      if (freeHitNextBall) {
        freeHit = true;
        freeHitNextBall = false;
        updateFreeHitDisplay();
      }

      // 1. Check for no ball (both 0)
      if (batCard === 0 && bowlCard === 0) {
        if (!isTestMatch) {
          outcome = "NO BALL! +1 run (Free Hit next ball)";
          runs += 1;
          currentInningRuns += 1;
          freeHitNextBall = true;
          isLegalBall = false;
        } else {
          outcome = "No run (Test Match)";
        }
      } 
      // 2. Handle free hit balls
      else if (freeHit) {
        if (batCard === bowlCard && batCard > 0) {
          outcome = "Wicket on Free Hit (not out)";
          isWicket = false;
        } else {
          runsScored = batCard;
          runs += batCard;
          currentInningRuns += batCard;
          outcome = `${batCard} Run(s)! (Free Hit)`;
          if (batCard === 4 || batCard === 6) boundary = true;
          if (batCard === 6) isSix = true;
        }
        freeHit = false;
        updateFreeHitDisplay();
        isLegalBall = true;
      }
      // 3. Handle wickets (same number > 0)
      else if (batCard === bowlCard && batCard > 0) {
        let wicketValue;
        if (isTestMatch) {
          wicketValue = 0.33;
        } 
        else if (currentFormat.name === "ODI") {
          wicketValue = isPowerplay ? 0.25 : 0.5;
        }
        else {
          wicketValue = isPowerplay ? 0.5 : 1.0;
        }
        
        batterWickets[currentBatter] = (batterWickets[currentBatter] || 0) + wicketValue;
        wickets += wicketValue;
        
        if (batterWickets[currentBatter] >= 1.0) {
          isPlayerOut = true;
          outcome = "WICKET! (Out)";
          wickets = Math.ceil(wickets);
          batterWickets[currentBatter] = 0;
          fallOfWickets.push({
            score: runs,
            over: `${Math.floor(legalBalls/6)}.${legalBalls%6}`,
            batter: currentBatter
          });
        } else {
          outcome = `WICKET! (${(1.0 - batterWickets[currentBatter]).toFixed(2)} wickets left)`;
        }
        
        isLegalBall = true;
        isWicket = true;
      }
      // 4. Handle batter playing 0
      else if (batCard === 0 && bowlCard > 0) {
        if (zerosThisOver[battingPlayer] > 3) {
          runs -= 5;
          outcome = "4th 0 in over! -5 runs";
        } else {
          if (isTestMatch) {
            bowlerRuns[currentBowler] = (bowlerRuns[currentBowler] || 0) + bowlCard;
            outcome = `Bowler's ${bowlCard} runs added to their stats`;
          } else {
            runsScored = bowlCard;
            runs += bowlCard;
            currentInningRuns += bowlCard;
            outcome = `Batter played 0. Runs = ${bowlCard}`;
            if (bowlCard === 4 || bowlCard === 6) boundary = true;
            if (bowlCard === 6) isSix = true;
          }
        }
        isLegalBall = true;
      }
      // 5. Handle bowler playing 0
      else if (bowlCard === 0 && batCard > 0) {
        if (zerosThisOver[bowlingPlayer] > 3 && !isTestMatch) {
          outcome = "4th 0 in over! No ball";
          runs += 1;
          freeHitNextBall = true;
        } else {
          if (isTestMatch) {
            runsScored = batCard;
            runs += batCard;
            currentInningRuns += batCard;
            outcome = `${batCard} Run(s)!`;
            if (batCard === 4 || batCard === 6) boundary = true;
            if (batCard === 6) isSix = true;
          } else {
            outcome = "DOT BALL!";
          }
        }
        isLegalBall = true;
      }
      // 6. Normal runs
      else {
        runsScored = batCard;
        runs += batCard;
        currentInningRuns += batCard;
        outcome = `${batCard} Run(s)!`;
        if (batCard === 4 || batCard === 6) boundary = true;
        if (batCard === 6) isSix = true;
        isLegalBall = true;
      }

      // Update batter stats
      if (currentBatter && runsScored > 0) {
        batterStats[currentBatter] = batterStats[currentBatter] || { runs: 0, balls: 0, fours: 0, sixes: 0 };
        batterStats[currentBatter].runs += runsScored;
        batterStats[currentBatter].balls += 1;
        
        if (batCard === 4) batterStats[currentBatter].fours += 1;
        if (batCard === 6) batterStats[currentBatter].sixes += 1;
      }
      
      // Update bowler stats
      if (currentBowler) {
        bowlerStats[currentBowler] = bowlerStats[currentBowler] || { wickets: 0, runs: 0, overs: 0 };
        if (isWicket) bowlerStats[currentBowler].wickets += 1;
        bowlerStats[currentBowler].runs += runsScored;
      }

      // Record ball in ball-by-ball
      ballByBall[legalBalls] = {
        runs: runsScored,
        wicket: isWicket || isPlayerOut,
        batter: currentBatter,
        bowler: currentBowler,
        timestamp: Date.now(),
        outcome: outcome
      };

      // Record last wicket score for partnership
      if (isWicket) {
        lastWicketScore = runs;
      }

      // Handle legal balls
      if (isLegalBall) {
        legalBalls++;
        if (isTestMatch) oversToday++;
        
        if (currentBowler) {
          bowlerOvers[currentBowler] = (bowlerOvers[currentBowler] || 0) + (1/6);
          if (legalBalls % 6 === 0) {
            bowlerOvers[currentBowler] = Math.round(bowlerOvers[currentBowler] * 10) / 10;
            zerosThisOver = { player1: 0, player2: 0 };
          }
        }
        
        // Check for end of day's play in test matches
        if (isTestMatch && oversToday >= maxOversPerDay) {
          endDaysPlay();
          return;
        }
      }

      // Update UI
      status.innerText = outcome;
      updateScoreboard();
      updateSpectatorData();
      
      // Check for milestones
      checkMilestones();
      checkBattingMilestones();

      // Check for match/innings end conditions
      if (innings === 2 && runs > team1Score) {
        endMatch();
        return;
      }
      
      if ((isTestMatch && currentInningWickets >= 30) || 
          (!isTestMatch && (wickets >= currentFormat.totalWickets || legalBalls >= currentFormat.totalOvers * 6))) {
        endInning();
        return;
      }

      // Prepare for next ball
      setTimeout(async () => {
        await resetPlays();
        
        if ((isPlayerOut || isWicket) && player === battingPlayer) {
          batterSelected = false;
          showBatterSelection();
        } else if (isLegalBall && legalBalls % 6 === 0) {
          bowlerSelected = false;
          if (player === bowlingPlayer) {
            showBowlerSelection();
          } else {
            status.innerText = "Waiting for opponent to select bowler...";
          }
        } else {
          updateButtonStates();
        }
      }, 1500);
    }

    // Set up Firebase listeners
    function setupFirebaseListeners() {
      let playTimeout;

      // Handle plays from both players
      onValue(playsRef, async (snap) => {
        const plays = snap.val();
        
        if (!plays || plays.player1 === undefined || plays.player2 === undefined) {
          return;
        }

        if (plays.player1 === null || plays.player2 === null) {
          return;
        }

        // Check opponent connection
        const connectionSnap = await get(opponentRef);
        if (!connectionSnap.exists() || !connectionSnap.val()) {
          status.innerText = "Opponent disconnected. Waiting...";
          return;
        }

        // Determine batting and bowling players
        const battingPlayer = innings % 2 === 1 ? battingFirst : (battingFirst === "player1" ? "player2" : "player1");
        const bowlingPlayer = battingPlayer === "player1" ? "player2" : "player1";

        const batCard = plays[battingPlayer];
        const bowlCard = plays[bowlingPlayer];

        // Process the outcome
        await processBallOutcome(batCard, bowlCard, battingPlayer, bowlingPlayer);
      });

      // Listen for current batter changes
      onValue(batterRef, (snap) => {
        const batter = snap.val();
        if (batter && batter !== currentBatter) {
          currentBatter = batter;
          currentBatterEl.innerText = batter;
          batterSelected = true;
          if (!battersUsed.includes(batter)) {
            battersUsed.push(batter);
            if (batterWickets[batter] === undefined) {
              batterWickets[batter] = 0;
            }
          }
          updateButtonStates();
        }
      });

      // Listen for current bowler changes
      onValue(bowlerRef, (snap) => {
        const bowler = snap.val();
        if (bowler && bowler !== currentBowler) {
          currentBowler = bowler;
          currentBowlerEl.innerText = bowler;
          bowlerSelected = true;
          updateButtonStates();
        }
      });

      // Listen for follow-on status
      onValue(followOnRef, (snap) => {
        const followOnBtn = document.getElementById("enforceFollowOn");
        if (followOnBtn) {
          followOnBtn.style.display = snap.exists() && snap.val() ? "block" : "none";
        }
      });

      // Listen for spectator count
      onValue(spectatorsRef, (snap) => {
        const spectators = snap.val() || {};
        spectatorCountEl.textContent = `üë• Spectators: ${Object.keys(spectators).length}`;
      });

      // Listen for reactions
      onValue(reactionsRef, (snap) => {
        const reactions = snap.val();
        if (!reactions) return;
        
        const lastReaction = Object.values(reactions).pop();
        if (lastReaction && lastReaction.player !== player) {
          showReaction(lastReaction.emoji);
        }
      });
    }

    // Show reaction emoji
    function showReaction(emoji) {
      const reactionEl = document.createElement('div');
      reactionEl.textContent = emoji;
      reactionEl.style.position = 'fixed';
      reactionEl.style.fontSize = '48px';
      reactionEl.style.animation = 'fadeInOut 2s';
      reactionEl.style.zIndex = '999';
      reactionEl.style.left = `${Math.random() * 70 + 15}%`;
      reactionEl.style.top = `${Math.random() * 70 + 15}%`;
      document.body.appendChild(reactionEl);
      setTimeout(() => reactionEl.remove(), 2000);
    }

    // Set up card button events
    function setupCardButtons() {
      buttons.forEach(btn => {
        btn.addEventListener("click", async () => {
          const val = parseInt(btn.dataset.value);
          disableButtons();
          status.innerText = "Waiting for opponent...";
          
          try {
            const opponentOnline = await get(opponentRef);
            if (!opponentOnline.exists() || !opponentOnline.val()) {
              status.innerText = "Opponent is offline!";
              updateButtonStates();
              return;
            }
            
            await update(playsRef, {
              [player]: val
            });
          } catch (error) {
            console.error("Error submitting play:", error);
            status.innerText = "Error submitting play - try again";
            updateButtonStates();
          }
        });
      });
    }

    // End current inning
    async function endInning() {
      disableButtons();
      
      // Update team scores
      if (innings === 1) {
        team1Score = currentInningRuns;
        team1Wickets = wickets;
        status.innerText = `Team 1 scored ${team1Score} runs!`;
        
        if (!isTestMatch) {
          startInningsBtn.style.display = "block";
          status.innerText += " Click 'Start Second Innings' when ready.";
          
          await set(inningsReadyRef, false);
          
          // Set auto-start timer for 30 seconds
          const autoStartTime = Date.now() + 30000;
          await set(autoStartTimeRef, autoStartTime);
          
          return;
        }
      } else {
        team2Score = currentInningRuns;
        team2Wickets = wickets;
        status.innerText = `Team 2 scored ${team2Score} runs!`;
      }
      
      // Check for follow-on in test matches
      const followOnPossible = isTestMatch && innings === 2 && team1Score - team2Score >= 200;
      
      if (followOnPossible) {
        status.innerText = `Team 1 can enforce follow-on (lead of ${team1Score - team2Score})`;
        await set(followOnRef, true);
      } else {
        if (isTestMatch) {
          innings++;
          if (innings > 2) {
            endMatch();
            return;
          }
          resetInning();
        }
      }
      
      updateScoreboard();
      updateSpectatorData();
    }

    // Reset inning state
    async function resetInning() {
      runs = 0;
      wickets = 0;
      currentInningRuns = 0;
      currentInningWickets = 0;
      legalBalls = 0;
      oversToday = 0;
      battersUsed = [];
      bowlerOvers = {};
      batterWickets = {};
      freeHit = false;
      freeHitNextBall = false;
      currentBatter = null;
      currentBowler = null;
      batterSelected = false;
      bowlerSelected = false;
      zerosThisOver = { player1: 0, player2: 0 };
      fallOfWickets = [];
      
      await update(playsRef, { player1: null, player2: null });
      
      isBatting = (innings % 2 === 1) ? (player === battingFirst) : (player !== battingFirst);
      
      startInningsBtn.style.display = "none";
      opponentReadyStatus.style.display = "none";
      autoStartTimerEl.style.display = "none";
      startInningsText.textContent = "Start Second Innings";
      
      await set(inningsReadyRef, false);
      await set(autoStartTimeRef, null);
      await set(batterRef, null);
      await set(bowlerRef, null);
      
      setupRole();
    }

    // End day's play (Test matches)
    function endDaysPlay() {
      disableButtons();
      status.innerText = "Stumps for the day!";
      daysRemaining--;
      
      setTimeout(() => {
        if (daysRemaining > 0) {
          oversToday = 0;
          updateButtonStates();
          status.innerText = `Day ${6 - daysRemaining} starting...`;
          updateScoreboard();
          updateSpectatorData();
        } else {
          endMatch();
        }
      }, 3000);
    }

    // End match and show result
    async function endMatch() {
      let result = "";
      let winner = "";
      let winMargin = 0;
      
      if (isTestMatch) {
        if (team1Score > team2Score) {
          winMargin = team1Score - team2Score;
          result = `Team 1 wins by ${winMargin} runs`;
          winner = "player1";
        } else if (team2Score > team1Score) {
          winMargin = 10 - Math.floor(team2Wickets);
          result = `Team 2 wins by ${winMargin} wickets`;
          winner = "player2";
        } else {
          result = "Match drawn";
        }
      } else {
        if (innings === 2) {
          if (team2Score > team1Score) {
            winMargin = currentFormat.totalWickets - Math.floor(team2Wickets);
            result = `Team 2 wins by ${winMargin} wickets`;
            winner = "player2";
          } else if (team1Score > team2Score) {
            winMargin = team1Score - team2Score;
            result = `Team 1 wins by ${winMargin} runs`;
            winner = "player1";
          } else {
            result = "Match tied";
          }
        } else {
          winMargin = currentFormat.totalWickets - Math.floor(team1Wickets);
          result = `Team 1 wins by ${winMargin} wickets`;
            winner = "player1";
        }
      }
      
      // Show winner celebration
      if (winner) {
        const winnerName = winner === "player1" ? 
          team1NameEl.textContent : team2NameEl.textContent;
          
        showNotification(`${winnerName} wins the match! üèÜ`, 'winner');
        createConfetti();
        
        // Highlight winning team
        if (winner === "player1") {
          team1NameEl.classList.add('team-winner');
          document.querySelectorAll('#team1Players li').forEach(li => {
            li.classList.add('team-winner');
          });
        } else {
          team2NameEl.classList.add('team-winner');
          document.querySelectorAll('#team2Players li').forEach(li => {
            li.classList.add('team-winner');
          });
        }
      }
      
      status.innerText = `Match Over! ${result}`;
      disableButtons();
      
      // Save result to Firebase
      await set(resultRef, result);
      updateSpectatorData();
      
      // Redirect to results page after delay
      setTimeout(() => {
        window.location.href = `result.html?room=${room}&player=${player}&winner=${winner}&result=${encodeURIComponent(result)}`;
      }, 5000);
    }

    // Initialize the game
    async function initGame() {
      try {
        status.innerText = "Initializing game...";
        
        gameInProgress = true;
        status.innerText = "Initializing game...";
        
        // Check if room exists
        const roomSnap = await get(roomRef);
        if (!roomSnap.exists()) {
          showNotification("Room does not exist!", 'error');
          setTimeout(() => window.location.href = "index.html", 2000);
          return;
        }

        const roomData = roomSnap.val();
        
        // Check toss status first
        if (!roomData.tossWinner || !roomData.battingFirst) {
          showNotification("Toss not completed yet!", 'info');
          setTimeout(() => window.location.href = `toss.html?room=${room}&player=${player}`, 2000);
          return;
        }

        // Get toss and batting first info
        tossWinner = roomData.tossWinner;
        battingFirst = roomData.battingFirst;
        
        // Load teams - don't fail if teams aren't loaded yet
        const teamsLoaded = await loadPlaying11();
        if (!teamsLoaded) {
          setTimeout(initGame, 3000);
          return;
        }

        // Set game format
        const format = roomData.player1?.format || "5";
        currentFormat = formatRules[format];
        isTestMatch = format === "test";
        
        formatDisplay.innerText = `${currentFormat.name} | ${isTestMatch ? "3 wickets per batter" : "1 wicket per batter"}`;
        
        // Initialize batter stats
        initializeBatterStats();

        // Set up game components
        setupConnectionMonitoring();
        await setupRole();
        setupSelectionModal();
        setupTestControls();
        setupInningsButton();
        setupCardButtons();
        setupFirebaseListeners();
        
        // Set up control buttons
        saveBtn.addEventListener("click", saveGameState);
        exitBtn.addEventListener("click", async () => {
          if (confirm("Exit without saving?")) {
            await resetGame();
            window.location.href = "index.html";
          }
        });
        
        resetPlaysBtn.addEventListener("click", async () => {
          if (confirm("Force reset the current plays?")) {
            await resetPlays();
            status.innerText = "Plays manually reset";
          }
        });

        // Set up AI opponent if in AI mode
        if (localStorage.getItem("aiMode") === "true" && player === "player1") {
          onValue(ref(db, `rooms/${room}/currentPlays/player1`), (snap) => {
            if (snap.exists()) {
              setTimeout(() => {
                const aiCard = Math.floor(Math.random() * 7);
                set(ref(db, `rooms/${room}/currentPlays/player2`), aiCard);
              }, 800);
            }
          });
        }

        // Initial UI update
        updateScoreboard();
        status.innerText = "Game ready!";
      } catch (error) {
        console.error("Initialization error:", error);
        showNotification("Failed to initialize game", 'error');
        setTimeout(initGame, 3000); // Retry instead of redirecting immediately
      }
    }

    // Start the game
    initGame();
  </script>
</body>
    </html>
